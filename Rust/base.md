<span id="catalog"></span>
- [基本使用](#基本使用)
- [常见编程概念](#常见编程概念)
    - [变量和可变性](#变量和可变性)
    - [数据类型](#数据类型)
    - [语句和表达式](#语句和表达式)
    - [函数](#函数)
    - [控制流](#控制流)

# 基本使用
[top](#catalog)
* Rust是一种**预编译静态类型**语言
* 安装Rust：
    * 检测安装成功
        * 检测Rust：`rustc --version`
        * 检测Cargo：`cargo --version`
* Rust的代码以`.rs`为文件后缀
* Rust的代码包称为**crates**
* 基本的编译与运行
    * 编译指令：`rustc xxx.rs`
    * 编译后生成：`xxxx.exe/xxxx`可执行文件，使用CMD时会有一个包含调试信息的文件`xxxx.pdb`

* 使用Cargo
    * 创建项目
        * 创建指令:`cargo new 项目名`
        * 生成的结果
            ```
            项目名
            |--- .gitignore
            |--- Cargo.toml
            |--- src
                |--- main.rs
            ```
        * Cargo期望用户**将代码放在src下**，根目录下放**README、license 信息、配置文件和其他跟代码无关的文件**
        * Cargo.toml文件的内容
            ```xml
            [package]
            name = "xxxx"
            version = "0.1.0"
            authors = ["Your Name <you@example.com>"]
            edition = "Rust版本"

            [dependencies]
            //在下面添加工程依赖
            ```
    * 编译、运行项目
        * 编译指令:`cargo build`
            * 在工程目录下执行该指令
            * 构建之后，会在工程目录下创建一个可执行文件：`target/debug/工程名`
            * 第一次运行该指令，将会在项目的根目录下创建一个新文件`Cargo.lock`
                * 该文件记录了依赖的实际版本，不需要做修改
        * 编译并运行:`cargo run`
            * 如果Cargo发现代码没有修改将不会重新构建项目，而是直接运行旧的二进制文件
        * 快速检测代码:`cargo check`
            * 该指令会快速检查代码确保它可以编译
            * 执行该指令**不会产生可执行文件**
            * `cargo check`比`cargo build`快，因为他忽略了生成可执行文件的步骤
    * 发布项目(release)
        * `cargo build --release`
            * 该指令视为了构建最终程序，编译速度比较慢
* Rust和Cargo的指令在各系统中都相同

* 编译与运行相互独立
* 每一行以`;`结尾
* 调用方法/宏
    * `method!(...);`，如果方法名后面有`!`，表示调用宏
    * `method(...);`，表示调用方法

# 常见编程概念
## 变量和可变性
[top](#catalog)
* 不可变变量
    * 创建常量：`let x = 5`
    * 常量只能赋值一次，否则会产生编译错误
    * 可以通过**隐藏特性**来创建新的同名的新变量
* 可变变量
    * `let mut x = 5;`
    * 值可以改，类型不可以改
* 常量
    * `const xxx: 类型 = xxxx;`
* 变量后可以增加类型声明：`let x: i8 = 5`
* 隐藏 Shadowing
    * 通过重复使用`let`来隐藏之前设定的变量值
    * 可以进行多次隐藏
        ```rust
        fn main() {
            let x = 5;
            println!("the value of x is:{}", x);
            let x = x+1;
            println!("the value of x is:{}", x);
            let x = x*2;
            println!("the value of x is:{}", x);
        }
        ```
    * 隐藏时，实际上是**创建了一个新变量，可以改变变量的类型，并复用这个变量名**

* **常量命名规范：使用下划线分隔大写字母单词**
* **可以在数字字面值中插入下划线来提升可读性**

## 数据类型
[top](#catalog)
* Rust中的每一个值都属于某一个数据类型
* 转换数据类型时必须设定数据类型注解
    * `let x: u32 = "42".parse().expect("Not a number!");`
* 标量类型
    * 标量类型代表一个单独的值
    * 四种基本的标量类型
        1. 整型
            * 可用类型

                |长度|有符号|无符号|
                |-|-|-|
                |8-bit|i8|u8|
                |16-bit|i16|u16|
                |32-bit|i32|u32|
                |64-bit|i64|u64|
                |arch|isize|usize|
            * `isize` 和 `usize`依赖于运行程序的计算机架构
                * 64位架构上是64位
                * 32位架构上是32位
            * 默认的整型类型是i32，通常是最快的？？？
            * 在64位系统上，`isize`、`usize`主要作为某些集合的索引
            * byte以外的所有数字字面值，**允许使用类型后缀**，如u8类型的数字：`57u8`
            * 整型字面值示例

                |数字字面值|例子|
                |-|-|
                |Decimal|98_222|
                |Hex|0xff|
                |Octal|0o77|
                |Binary|0b1111_0000|
                |Byte(u8 only)|b'A'|
            * 整型溢出
                * 在debug模式编译时，Rust会检查这类问题并使程序panic
                * 在release构建中，Rust不检测溢出，会转换成二进制补码
        2. 浮点型
            * 表示带小数点的数字
            * 两种浮点类型：`f32`、`f64`
            * 默认类型是:`f64`
                * 该类型在现代CPU中与`f32`速度机会一样，不过精度更高
            ```rust
            fn main() {
                let x = 2.0; // 默认为f64
                let y: f32 = 3.0; // f32
            }
            ```
        3. 布尔型
            * `bool`表示布尔型变量
            * 两个可能的值：`true`、`false`
            ```rust
            fn main() {
                let t = true;
                let f: bool = false;
            }
            ```
        4. 字符类型
            * `char`表示字符型
            * 字符类型表示**语言中最原生的字母类型**
            * 大小为4byte
            * 代表了一个Unicode标量值
            * Rust中，中文、日文、韩文、emoji字符、0长度的空字符 等，都是有效char值
            * 表示的范围：`U+0000~U+D7FF` 和 `U+E000`
* 复合类型
    * 将多个值组合成一个类型
    * Rust的两个原生复合类型
        1. 元组tuple
            * `(,)`创建元祖
            * 每个位置都有一个类型，这些**类型可以不相同，可以使用类型注解**
                ```rust
                let tup: (i32, f64, u8) = (500, 6.4, 1);
                ```
            * 元祖的解构赋值(模式匹配)
                ```rust
                let tup = (500, 6.4, 1);
                let (x, y, z) = tup;
                ```
            * 直接访问方式:`元祖名.index`
                ```rust
                let x:(i32, f64, u8) = (500, 6.4, 1);
                let y = x.0;
                ```
        2. 数组array
            * `[,]`创建数组
            * **数组每个元素的类型必须相同**
            * Rust中的数组是**固定长度**的，长度不能变化: `let a = [1,2,3,4,5];`
            * 数组的类型：`[type; number]`
                `let a [i32; 5] = [1, 2, 3, 4, 5];`
            * **当想要在栈上为数据分配空间、或者想要确保总是有固定数量的元素时，应该使用数组**
            * 如果不确定数组大小应该使用vector
            * 数组是**分配在栈上的连续内存**，可以使用索引来访问数组元素
                ```rust
                let a = [1, 2, 3, 4, 5];
                let first = a[0];
                ```
            * 越界访问，编译时不会产生异常，执行时会产生一个panic
                * 通过index访问数组时，**会检查索引是否小于数组的长度，超过了会长生panic，不会指向无效内存**

## 语句和表达式
[top](#catalog)
* 语句
    * 执行一些操作但不返回值的指令
    * 如：`let y = 6;`
    * 语句不能赋给另一个变量
    * 已`;`结尾
* 表达式
    * 能够计算并产生一个值
    * **表达式的结尾没有`;`**，加上`;`就变成了语句
    * 表达式可以是语句中的一部分
    * `let y = 6;`中`6`是一个表达式
    * 函数调用是一个表达式
    * 宏调用是一个表达式
    * 代码块`{...}`是一个表达式
        * 如
            ```rust
            let y = {
                let x = 3;
                x + 1 //表达式，返回x+1的结果
            }; //结尾必须有分号
            ```
        * 代码块的值是其最后一个表达式的值
## 函数
[top](#catalog)
* `fn 函数名(参数1: 类型, 参数2: 类型,....) -> 返回值类型`
    * 函数的返回值等同于**函数体的最后一个表达式的值**
    * 使用`return`指定返回值
    * 大部分函数**隐式的返回最后的表达式**
        ```rust
        fn five() -> i32{
            5 //没有';'，是表达式，且是最后一个表达式，会作为返回值返回
        }

        fn main(){
            let x = five();
            println!("{}", x)
        }
        ```
    * 控制台的错误信息中会使用空元祖`()`来表示不返回值
* `fn main(){}`，在可运行的rust程序中，`main`总是最先运行的代码，并且**没有参数，也没有返回值**
* 函数和变量使用snake case风格，所有字母都是小写并使用下划线分隔单词
* 函数的参数**是函数签名的一部分**

## 控制流
[top](#catalog)
* if表达式
    * 基本格式
        ```rust
        if exp {
            ...
        } else if exp{
            ...
        } else {
            ...
        }
        ```
    * 每个分支的判断exp的结果必须是`bool`类型
    * if 是有一个表达式，可以在let语句的右侧使用它
        ```rust
        let condition = true;
        let number = if condition {
            5
        } else {
            6
        }; //必须已';'结尾

        println!("{}", number);
        ```
        * 每个分支的数据类型必须相同，否则代码无法编译
            ```rust
            let number = if condition {
                5
            } else {
                "xxxx" //将会产生编译异常
            };
            ```
* 循环
    * loop 循环
        * **loop是一个表达式**
        * 可以使用break来停止循环
            * break可以添加返回值：`break 返回值;`
        ```rust
        let mut count = 0;
        let result = loop {
            count += 1;
            if count == 10{
                break count + 2;
            }
        };

        println!("{}", result)
        ```