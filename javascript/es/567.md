<span id="catalog"></span>

### 目录
- [ECMAScript基本知识](#ECMAScript基本知识)
- [ES5](#ES5)
    - [严格模式](#严格模式)
        - [严格模式说明](#严格模式说明)
        - [严格模式下的语法和行为](#严格模式下的语法和行为)
        - [严格模式的范围](#严格模式的范围)
        - [非严格模式的全局环境](#非严格模式的全局环境)
    - [json扩展](#json扩展)
    - [Object对象扩展](#Object对象扩展)
        - [常用扩展方法](#常用扩展方法)
        - [扩展方法的使用方式](#扩展方法的使用方式)
    - [ES5-Array扩展](#ES5-Array扩展)
    - [Function对象的扩展](#Function对象的扩展)
- [ES6](#ES6)
    - [let关键字](#let关键字)
    - [const关键字](#const关键字)
    - [解构赋值与函数对象参数解构](#解构赋值与函数对象参数解构)
    - [模板字符串](#模板字符串)
    - [对象的简写方式](#对象的简写方式)
    - [箭头函数](#箭头函数)
    - [展开运算符与函数的剩余参数](#展开运算符与函数的剩余参数)
    - [形参默认值](#形参默认值)
    - [Promise对象](#Promise对象)
        - [Promise对象说明](#Promise对象说明)
        - [Promise对象的使用方法](#Promise对象的使用方法)
        - [简化只有数据的Promise对象](#简化只有数据的Promise对象)
        - [Promise.all--等待所有异步调用完成](#Promise.all--等待所有异步调用完成)
    - [Symbol属性](#Symbol属性)
    - [Iterator迭代器接口](#Iterator迭代器接口)
        - [Iterator的概念与使用方法](#Iterator的概念与使用方法)
        - [Iterator的工作原理与自定义实现](#Iterator的工作原理与自定义实现)
    - [Generator函数](#Generator函数)
        - [Generator函数与使用方法](#Generator函数与使用方法)
        - [通过Generator函数创建自定义迭代器](#通过Generator函数创建自定义迭代器)
    - [class](#class)
    - [String扩展](#String扩展)
    - [Number扩展](#Number扩展)
    - [ES6-Array扩展](#ES6-Array扩展)
    - [Object的扩展方法](#Object的扩展方法)
    - [拷贝](#拷贝)
        - [浅拷贝](#浅拷贝)
        - [深拷贝-JSON转换](#深拷贝-JSON转换)
        - [深拷贝-自定义深拷贝实现](#深拷贝-自定义深拷贝实现)
    - [set容器](#set容器)
    - [map容器](#map容器)
    - [for_of循环](#for_of循环)
- [es7](#es7)
    - [async函数](#async函数)
        - [async函数的概念与基本使用](#async函数的概念与基本使用)
        - [async函数的执行顺序](#async函数的执行顺序)
    - [指数幂运算符](#指数幂运算符)
    - [ES7-Array扩展](#ES7-Array扩展)
- [](#)


# ECMAScript基本知识
[top](#catalog)
- ECMAScript是有ECMA组织指定和发布的脚本语言规范
- 常用的JS是ECMAScript的一种实现，但一般JS和ECMAScript的含义相同
- 创建的ES扩展
    - 浏览器端的JS
    - NodeJS
- ES的几个重要版本
    - ES5：09年发布
    - ES6（ES2015）：15年发布
    - ES7（ES2016）：16年发布

# ES5
## 严格模式
### 严格模式说明
[top](#catalog)
- 一般的代码中使用的都是普通模式，也成为混杂模式
- ES5中添加了第二种运行模式：严格模式，`strict mode`
- 严格模式的作用
    - 消除JS语法中的不严谨、不合理的地方，减少意外行为
    - 提升代码的安全性
    - 为未来的JS版本做铺垫
- 使用方法
    - 通过**指示前缀**: `'use strict';`，开启严格模式
        - 如果浏览器版本不支持，则会被解析为一条简单的语句，没有任何副作用
    - 指示前缀可以出现的位置
        1. 全局代码开始处
        2. `eval()` 函数的代码字符串开始处
        3. 函数声明代码的开始处
        4. `new Function()` 传入的 body 参数块的开始处
    - 在代码的中间使用指示前缀而不是开头，则指示前缀无效
        ```js
        var a = 100;
        'use strict';   // 指示前缀无效
        var b = 123; 
        ```
    - 默认处于严格模式的代码
        1. 模块中的代码 
        2. `class`、`class...extends` 类声明和类表达式的整个声明块中
        3. 在NodeJs通过指令限制严格模式: `node --use_strict`

- 严格模式的生效时间
    - 全局作用域的严格模式在语法编译期生效
        - 如果有问题，整个代码块失效，并导致一个语法异常
    - 函数作用域的严格模式在运行期生效
        - 如果有问题，会抛出执行异常

### 严格模式下的语法和行为
[top](#catalog)
- 使用严格模式后，**语法和行为的改变**
    1. 必须使用 `var` 声明变量
    2. 禁止自定义函数中的 `this` 指向 `window`
    3. 将会为 `eval('...')` 函数执行的代码创建单独的作用域
    4. 对象不能有重名属性
    5. 函数的参数名，不能同名
        ```js
        function foo (m, m){} 
        ```
    5. 不能使用 `with` 语句
    6. js的保留字、eval、arguments 等不能被重写
    7. 不能访问 `arguments.callee`
    8. 不能访问 `函数.caller`

- 语法和行为的改变说明
    1. 禁止自定义函数中的 `this` 指向 `window`
        - 即防止 `构造函数(...)` 这样的直接调用
        - 这种直接调用会将 window对象 绑定到 this
        - 防止在构造函数内部需改 window对象 中的重要属性或函数
    2. 创建eval作用域
        - 如果不启动严格模式，eval中的代码在全局作用域中执行
        - 启动严格模式之后，为eval函数单独创建一个局部作用域
            - 代码字符串中的变量、函数等，都会变为局部作用域内的数据
        - 为什么要为eval函数创建单独的局部作用域?
            1. 假设eval中的代码字符串是从服务器返回的
            2. 如果代码字符串中参杂了恶意攻击的代码，这些代码直接操作 window对象，则用户很容易被攻击
    3. 对象不能有重名属性
        - 防止误操作导致的重命名
        - 这一条只是代码检查中会报错，实际执行时不会报错
        - 如果出现的重名属性，则后声明的会覆盖先声明的
- 示例
    - 参考代码
        - [src/es5/strict_mode/base.html](src/es5/strict_mode/base.html)
    - 代码内容
        ```js
        'use strict'
        // 1. 必须使用 `var` 声明变量
        // a = 100  // 异常：ReferenceError: a is not defined
        var a = 100
        console.log(100)

        // 2. 禁止自定义函数中的 `this` 指向 `window`
        function Person(name, age){
            this.name = name
            this.age = age
        }

        var p01 = new Person("aaa", 18)

        // 异常：TypeError: Cannot set property 'name' of undefined
        // Person("bbb", 20)

        // 3. 创建eval作用域
        var str = "outter str"
        eval('var str="inner str"; console.log(str)') // 输出:inner str
        console.log(str)
        // 普通模式，输出：inner str，即修改了全局作用域中的变量
        // 严格模式，输出：outter str

        // 4. 对象不能有重名属性
        var obj = {
            name:"aaaa",
            name:"bbb"
        }
        console.log(obj.name)
        // 不会报错
        // 输出: bbb
        ```

### 严格模式的范围
[top](#catalog)
- 全局作用域严格模式
    - 第一行代码是 `"use strict";`，则后面所有代码都是严格模式
        ```js
        "use strict";
        
        var a = 2;
        function foo(){
            var arguments;  // 编译异常
        }
        ```
- 函数作用域严格模式
    ```js
    var arguments;  // 全局作用域没有异常
    function foo(m, m){ // 函数什么名也处于严格模式中
        "use strict";   // 函数作用域内部是严格模式

        var eval;   // 
    }
    ```

- 在代码中间不会生效
    ```js
    var a= 2;
    "use strict";
    var arguments;  // 不会生效
    ```

- 如果第一行是空行、注释，严格模式仍然会生效
    - 根据自动插入分号规则，如果插入分号后的解析结果是空语句，则不会插入分号，此处的严格模式**有效**
        ```js
        
        "use strict";
        var arguments;
        ```
    - 注释会被解释器忽略，所以严格模式**有效**
        ```js
        // ...
        "use strict";
        var arguments;
        ```
    - 函数的第一条语句以 `;` 结尾，是一条有效语句。`'use strict';` 被认为在语句中间，所以严格模式**无效**
        ```js
        function foo() { ; 'use strict'; var arguments; }
        ```
    - 函数开始空白不是语句，第一条语句仍然是 `'use strict';`，所以严格模式**有效**
        ```js
        function foo() {  'use strict'; var arguments; }
        ```

### 非严格模式的全局环境
[top](#catalog)
- 在严格模式中开启非严格模式的全局环境的方法
    1. 间接调用 `eval` 函数
    2. 使用 `new Function()` 创建函数
- 通过开启非严格模式的全局环境，可以继续使用传统的JS语法和技巧
- 示例
    - 参考代码
        - [src/es5/use_strict/no_strict_env.js](src/es5/use_strict/no_strict_env.js)
    - 代码内容
        ```js
        'use strict'
        function foo(){
            try{
                x = 1234;       // 没有通过 var 声明变量，在执行期发生异常
            } catch (e){
                console.log(e.message); // 输出1: x is not defined
            }

            console.log(typeof x);      // 输出2: undefined
            
            // 间接调用 eval
            (0, eval)('x = 1234');      // 使用正常的 JS 语法，【创建了一个全局变量 x】
            console.log(typeof x);      // 输出3: number
        }

        foo();
        console.log(x);                 // 输出4: 1234
        ```

## json扩展
[top](#catalog)
- `var JSON字符串 = JSON.stringify(JS对象)`
    - 将js对象转换为JSON字符串
- `var JS对象 = JSON.parse(JSON字符串)`
    - 将JSON字符串转换为js对象
- JSON只有两种类型
    - JSON数组
    - JSON对象

## Object对象扩展
### 常用扩展方法
[top](#catalog)
1. `Object.create(prototype [, descriptors])`，以某个对象为原型创建对象，并扩展属性
2. `Object.defineProperties(object, descriptors)`，为已有对象添加getter、setter
3. 创建对象时，对象自身的 getter、setter 方法

### 扩展方法的使用方式
[top](#catalog)
- `Object.create(prototype [, descriptors])`
    - 用途：
        1. 指定某个对象为原型创建新的对象
        2. 通过 `descriptors` 参数，为新对象扩展属性，并**对属性进行描述**
    - 如果 `prototype` 是 `null`，将会创建一个 空对象 `{}`, 并且该对象原型为 `null`
    - `descriptors` 参数的设置方法
        ```js
        {
            属性名: {
                value: 属性值,
                writable: 当前属性是否可修改（默认为false）,
                configurable: 当前属性是否可以被删除（默认为false）,
                enumerable: 当前属性是否能用 `for in` 进行枚举（默认为false）
            },
            ....
        }
        ```
    - 对于不可修改、不可删除、不可遍历的属性，可以执行对应的操作，不会报错，但是**操作不会生效**
    - 示例
        - 参考代码
            - [src/es5/object/extends.html](src/es5/object/extends.html)
        - 代码内容
            ```js
            // 1. 指定某个对象为原型创建新的对象
            var obj0101 = {name:'aaa', age:14}
            var obj0102 = Object.create(obj0101)
            console.log("obj0102.name =", obj0102.name)
            // 输出: obj0102.name = aaa
            console.log(obj0102)

            // 2. 在原型的基础上，通过 descriptors 参数，为新对象扩展属性
            var obj0201 = {name:'bbb', age:15}
            var obj0202 = Object.create(
                obj0201,
                {
                    gender:{
                        value:false,
                        writable:true,
                        configurable:true,
                        enumerable:true
                    },

                    address:{
                        value:"test address",
                        writable:false,
                        configurable:false,
                        enumerable:false
                    }
                }
            )

            // 2.1 修改可修改属性
            console.log("obj0202.gender =", obj0202.gender)
            // 输出: obj0202.gender = false

            obj0202.gender = true
            console.log("obj0202.gender =", obj0202.gender)
            // 输出: obj0202.gender = true

            // 2.2 修改不可修改属性
            console.log("obj0202.address) =", obj0202.address)
            // 输出: obj0202.address) = test address
            obj0202.address = "new address"
            console.log("obj0202.address) =", obj0202.address)
            // 输出: obj0202.address) = test address

            // 2.3 遍历所有属性
            for(var p in obj0202){
                console.log("p =", p)
            }

            // 遍历输出:
            // p = gender
            // p = name
            // p = age

            // 2.4 删除属性
            delete obj0202.gender //可删除
            delete obj0202.address //不可删除
            console.log("obj0202 =", obj0202)
            // 输出: obj0202 = {address: "test address"}
            ```

- `Object.defineProperties(object, descriptors)`
    - 用途:
        - 为已有的对象扩展属性
        - 用于替换:`obj.新属性 = 新属性值` 这种直接在对象上添加属性的方式
    - `descriptors` 参数的设置新属性的 getter、setter
        ```js
        {
            属性名:{
                get: function(){
                    // 获取扩展属性
                    // 内部可以使用 this 对象
                },
                set: function(data){
                    // 修改扩展属性
                    // 内部可以使用 this 对象
                    // 监听属性，当属性发生修改时，自动执行
                }
            }
        }
        ```
    - 示例
        - 参考代码
            - [src/es5/object/extends.html](src/es5/object/extends.html)

        - 代码内容
            ```js
            // 3. 为指定对象定义扩展多个属性
            var obj03 = {firstName:"aaa", lastName:"ccc"}
            Object.defineProperties(
                obj03,
                {
                    fullName:{
                        get: function(){
                            return this.firstName + " " + this.lastName
                        },
                        set: function(data){
                            var result = data.split(" ");
                            this.firstName = result[0]
                            this.lastName = result[1]
                        }
                    }
                }
            )

            console.log("obj03.fullName =", obj03.fullName)
            // 输出: obj03.fullName = aaa ccc
            obj03.fullName = "xxx yyy"
            console.log("obj03.fullName =", obj03.fullName)
            // 输出: obj03.fullName = xxx yyy
            ```

- 对象自身的 getter、setter 方法
    - 只能在创建对象时使用
    - 与 `Object.defineProperties(object, descriptors)` 的功能一致
        - 对象内部的结构也基本相同
    - 设置方法
        ```js
        var 对象 = {
            get 属性名(){
                // 获取属性值
                // 可以使用this对象
            }
            set 属性名(data){
                // 设置属性值
                // 可以使用this对象
            }
        }
        ```
    - 示例
        - 参考代码
            - [src/es5/object/extends.html](src/es5/object/extends.html)

        - 代码内容
            ```js
            // 4. 设置对象自身的getter和setter
            var obj04 = {
                firstName:"object",
                lastName:'04',
                get fullName(){
                    return this.firstName + " " + this.lastName
                },
                set fullName(data){
                    var result = data.split(" ")
                    this.firstName = result[0]
                    this.lastName = result[1]
                }
            }

            console.log("obj04.fullName =", obj04.fullName)
            // 输出: obj04.fullName = object 04
            obj04.fullName = "new name"
            console.log("obj04.fullName =", obj04.fullName)
            // 输出: obj04.fullName = new name
            ```

- 两种getter、setter设置方法的对比
    - 参考代码
        - [src/es5/object/extends.html](src/es5/object/extends.html)

    - 对比结果
        ```js
        // 5. 检查两种添加 getter、setter 方式的对象结构
        console.log(obj03)
        console.log(obj04)

        // obj03:   defineProperties
        // {firstName: "xxx", lastName: "yyy"}
        // firstName: "xxx"
        // lastName: "yyy"
        // fullName: (...)
        // get fullName: ƒ ()        <----getter函数名不同
        // set fullName: ƒ (data)    <----setter函数名不同
        // __proto__: Object

        // obj04:   getter、setter
        // {firstName: "new", lastName: "name"}
        // firstName: "new"
        // fullName: (...)
        // lastName: "name"
        // get fullName: ƒ fullName()      <----getter函数名不同
        // set fullName: ƒ fullName(data)  <----setter函数名不同
        // __proto__: Object
        ```

## ES5-Array扩展
[top](#catalog)
- Array 的显示原型对象上的扩展方法

    |扩展方法|描述|
    |-|-|
    |`Array.prototype.indexOf(value)`|获取 value 在数组中第一次出现的下标|
    |`Array.prototype.lastIndexOf(value)`|获取 value 在数组中最后一次出现的下标|
    |`Array.prototype.forEach(function(item, index){})`|遍历数组，并应用函数|
    |`Array.prototype.map(function(item, index){})`|<ul><li>遍历数组并返回一个新数组</li><li>对数组的每个元素应用变化函数</li><li>函数的返回值作为一个新数组的元素</li></ul>|
    |`Array.prototype.filter(function(item, index){})`|<ul><li>遍历数组并返回一个新数组</li><li>根据函数来过滤元素</li><li>函数的返回值`true`时，将当前遍历的元素添加到新数组中；返回`false`时，跳过当前元素</li></ul>|

- 数组的扩展内容都绑定在 Array函数对象的显示原型上，所以数组对象可以直接使用 （通过隐式原型）

- 这些扩展方法只是用于 Array 的实例对象与子类对象。但是**对于类数组对象不可用**

- 示例
    - 参考代码
        - [src/es5/array/extends.html](src/es5/array/extends.html)
    - 代码内容
        1. 输出第一个6的下标
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result01 = arr.indexOf(6)
            console.log("result01 =", result01)
            // 输出: result01 = 4
            ```
        2. 输出最后一个6的下标
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result02 = arr.lastIndexOf(6)
            console.log("result02 =", result02)
            // 输出: result02 = 8
            ```
        3. 输出所有元素的值和下标
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            arr.forEach(function(item, index){
                console.log("result03: index = " + index + ", arr[" + index + "] = " + arr[index])
            })
            ```
        4. 根据原始数组产生一个新数组，将数组的所有元素加10
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result04 = arr.map(function(item){
                return item + 10
            })
            console.log("result04 =", result04)
            // 输出: result04 = (10) [12, 13, 14, 15, 16, 17, 18, 19, 16, 10]
            ```

        5. 根据原始数组产生一个新数组，返回大于4的元素
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result05 = arr.filter(function(item){
                return item > 4
            })
            console.log("result05 =", result05)
            // 输出: result05 = (6) [5, 6, 7, 8, 9, 6]
            ```

## Function对象的扩展
[top](#catalog)
- `Function.prototype.bind(obj [, param1, param2])`
    - 用途：
        - 将函数内的this绑定为obj，并**返回一个新的函数对象**
        - 如果bind中还有其他参数，则按照顺序绑定到函数的参数中
    - 使用场景
        - 修改回调函数中的this对象
- bind 与 call、apply 的区别
    - call、apply 会立即执行
    - bind 会将函数返回，并延迟执行

- 示例
    - 参考代码
        - [src/es5/function/extends.html](src/es5/function/extends.html)
    - 代码内容
        1. 只绑定函数的this
            ```js
            // 1.1 原始函数
            function foo(data){
                console.log(this)
                console.log(data)
            }

            // 1.2 创建对象-->绑定this-->执行新的函数
            var obj = {name:"obj"}
            var bar = foo.bind(obj)
            bar(1234)
            // 输出:
            // {name: "obj"}
            // 1234

            // 1.2. 执行原始函数
            foo(5678)
            // 输出:
            // Window {parent: Window, …}
            // 5678
            ```
        2. 绑定 this 和函数的其他参数
            ```js
            function foo02(a, b){
                console.log(this)
                console.log("a =", a)
                console.log("b =", b)
            }

            var obj02 = {name:"obj02"}
            var bar02 = foo02.bind(obj02, 10)
            bar02(20)
            // 输出:
            // {name: "obj02"}
            // a = 10
            // b = 20

            ```

        3. 修改回调函数中的this
            ```js
            var obj03 = {name:"obj03"}
            setTimeout(
                (function(){console.log(this)}).bind(obj03),
                300
            )
            // 输出: {name: "obj03"}
            ```

# ES6
## let关键字
[top](#catalog)
- `let` 关键字
    - 作用：与 var 类似，用于声明变量
    - 特性
        - 使变量只在块级作用域内有效
        - 在作用域内，不能重复声明同名变量
        - 使变量在创建执行上下文时，不参与预处理，不被提升
    - 场景的应用场景
        - 循环遍历加监听
- 示例
    - 参考代码
        - [src/es6/let/base.html](src/es6/let/base.html)
    - 代码内容
        1. 在作用域内，不能重复声明同名变量
            ```js
            let a = 100
            // SyntaxError: Identifier 'a' has already been declared
            // let a = 200
            console.log(a)
            ```
        2. 使变量在创建执行上下文时，不参与预处理，不被提升
            ```js
            // 在变量声明之前，访问使用let声明的变量
            // ReferenceError: Cannot access 'b' before initialization
            // console.log(b)
            let b = 300
            ```
        3. 循环遍历加监听--- let 使变量只在块级作用域内有效
            ```js
            // 为每个按钮绑定点击事件。点击时输出自身的index
            var buttons = document.getElementsByTagName("button")
            var buttons_length = buttons.length
            for(let i=0; i<buttons_length; i++){
                // 每一次循环都会创建let对应的作用域，事件处理函数中只会使用当前作用域中的值
                buttons[i].onclick = function(){
                    console.log("i =", i)
                }
            }
            ```

## const关键字
[top](#catalog)
- const关键字
    - 作用: 定义一个常量
    - 特点
        - 常量不可以修改该
        - 与let类似
            - 使变量只在块级作用域内有效
            - 在作用域内，不能重复声明同名变量
            - 使变量在创建执行上下文时，不参与预处理，不被提升
- 如果const保存的是一个对象
    - const变量本身不能被修改
    - 对象内部的属性可以被修改
        ```js
        const obj = {
            a:'1111',
            b:'2222',
            c:'3333',
        }

        // 修改 const 变量内部的属性
        obj.a='aaaa';
        ```    

## 解构赋值与函数对象参数解构
[top](#catalog)
- 解构赋值与剩余参数的本质
    - 从对象或数组中提取数据，并赋值给（多个）变量
- 对象的解构
    - 语法
        - 需要用 `{}` 将多个变量括起来，如 `{param1, parm2} = 对象`
        - 与属性名相同的变量名会被赋值
        - 变量的顺序没有要求
        - 如果某个变量名在对象中**没有对应的属性名**，则只会声明，不会被赋值，即为 `undefined`
        - 可以通过 `{属性名: 别名}` 的方式，在解构时通过别名来使用属性
            - 如果声明了别名，只能通过别名来使用属性值
    - 完全匹配
        ```js
        let {name, age} = {name:"aaa_name", age:20}
        ```
    - 部分匹配
        ```js
        let {price, address} = {price:60, address:"qqq", school:"xxxx"}
        ```
    - 只匹配一个
        ```js
        let {one} = {one: "oneStr", two:"twoStr"}
        ```
    - 变量过多，无法匹配的自动忽略
        ```js
        let {first, second, third} = {first:"firstStr", second:"secondtr"}
        ```
    - 设置别名
        ```js
        let {aaa:alias01, bbb:alias02} = {"aaa":1111, "bbb":222, "third":33333}
        ```
    - 对象属性的深度遍历，等号左右需要**模式匹配**
        ```js
        // x=abcd
        let {p1:{p2:x}} = {p1:{p2:'abcd'}};
        ```
- 数组的解构
    - 语法
        - 需要用 `[]` 将多个变量括起来，如 `[aram1, parm2] = 数组`
        - 按下标顺序为每个变量赋值
            - 如果变量多了，则只定义，不赋值，即 `undefined`
            - 如果变量少了，只从数组中抽取对应数量的元素进行赋值
            - 不需要赋值的index，使用`,`来跳过
    - 完全匹配
        ```js
        let [a, b] = [1, 2]
        ```
    - 部分匹配
        ```js
        let [c, d] = [5, 6, 7, 8, 9]
        ```
    - 变量过多，无法匹配不赋值
        let [e, f, g] = [10, 11]
        ```
    - 跳过某个元素
        ```js
        let [h, , j] = [12, 13, 14]
        ```
    - 用展开运算符来捕获多余的元素
        ```js
        let [a, b, ...more] = [3, 4, 5, 6, 7, 8]
        ```

- 函数的对象类型参数解构
    - 解构的形式: `function 函数名({参数1, 参数2})`
    - 传递实参时直接传递对象
    - 如果函数使用了这种形式的参数，则**无法再通过一一传递参数的方式调用函数**
        - 如果使用传统方式调用，则形参值都是 `undefined`
    - 使用方法
        ```js
        // 使用解构的格式作为形参
        function foo({name, age}){
            
        }
        // 调用时，直接将对象作为实参传递，不需要通过 对象.属性名的方式，一一传递
        var obj = {...}
        foo(obj)
        ```

- 解构`try...catch`中的异常对象声明
    ```js
    try{
        ...
    } catch({属性1, 属性2,...}){

    }
    ```

- 示例
    - 参考代码
        - [src/es6/deconstruct/base.html](src/es6/deconstruct/base.html)
        - [src/es6/deconstruct/trycatch.js](src/es6/deconstruct/trycatch.js)
    - 代码内容
        1. 对象的解构
            ```js
            // 1.1 完全匹配
            let {gender, name, age} = {name:"aaa_name", age:20, gender:true}
            console.log("name =", name)         // name = aaa_name
            console.log("age =", age)           // age = 20
            console.log("gender =", gender)     // gender = true

            // 1.2 部分匹配
            let {price, address} = {price:60, address:"qqqwwweee", school:"xxxx"}
            console.log("price =", price)       // price = 60
            console.log("address =", address)   // address = qqqwwweee

            // 1.3 只匹配一个
            let {one} = {one: "oneStr", two:"twoStr"}
            console.log("one =", one)           // one = oneStr

            // 1.4 匹配对象中不存在的匹配项
            let {first, second, third} = {first:"firstStr", second:"secondtr"}
            console.log("first =", first)       // first = firstStr
            console.log("second =", second)     // second = secondtr
            console.log("third =", third)       // third = undefined

            // 1.5 解构时，设置别名
            let {aaa:alias01, bbb:alias02} = {"aaa":1111, "bbb":222, "third":33333};
            console.log("alias01 =", alias01)   // alias01 = 1111
            console.log("alias02 =", alias02)   // alias02 = 222
            // console.log("aaa =", aaa)        // aaa无法使用
            // console.log("bbb =", bbb)        // bbb无法使用

            // 1.6 对象属性的深度遍历
            let {p1:{p2:v}} = {p1:{p2:'abcd'}};
            console.log( 'v = ' + v);  // v = abcd
            ```

        2. 数组的解构
            ```js
            // 2.1 完全匹配
            let [a, b] = [1, 2]
            console.log("a =", a)
            console.log("b =", b)

            // 2.2 部分匹配
            let [c, d] = [5, 6, 7, 8, 9]
            console.log("c =", c)
            console.log("d =", d)

            // 2.3 变量过多，无法匹配 g，则不赋值
            let [e, f, g] = [10, 11]
            console.log("e =", e)
            console.log("f =", f)
            console.log("g =", g)

            // 2.4 跳过某个元素
            let [h, , j] = [12, 13, 14]
            console.log("h =", h)       // j = 14
            console.log("j =", j)       // h = 12

            // 2.5用展开运算符来捕获多余的元素
            let [x, y, ...more] = [3, 4, 5, 6, 7, 8]
            console.log("x =", x)       // x = 3
            console.log("y =", y)       // y = 4
            console.log("more =", more)       // more = [5, 6, 7, 8]
            ```

        3. 函数的对象类型参数解构
            ```js
            // 使用解构的格式作为形参
            function show({name, age, address: addr}){
                console.log("name =", name)
                console.log("age =", age)
                console.log('address=', addr)
            }

            var obj = {name: "objName", age:30, address:'asdfghhjk'}
            // 不需要依次调用对象的属性，直接将对象作为实参传递
            show(obj)
            // 输出:
            // name = objName
            // age = 30
            // address= asdfghhjk
            ```
        4. 解构 try...catch 中的异常对象
            ```js
            try {
                throw {msg:'errorMsg', code:0001}
            } catch({msg, code}){
                console.log('msg = ', msg);     // msg =  errorMsg
                console.log('code = ', code);   // code =  1
            }
            ```

## 模板字符串
[top](#catalog)
- 模板字符串的作用
    - 简化字符串的拼接

- 语法
    - 使用反引号将字符串括起来
    - 需要使用变量的部分，通过 `${变量}` 的方式来引用
    - 需要使用函数调用结果的部分，通过 `${函数()}` 的方式来引用
        ```
        `xxxxxx${变量}xxxx`
        `xxxxxx${fn()}xxxx`
        ```
    - 模板字符串中的空格和换行都会被保留

- 示例
    - 参考代码
        - [src/es6/string/template.html](src/es6/string/template.html)
    - 代码内容
        ```js
        // 1. 输出变量
        let obj = {
            name:"testName",
            age:20,
            gender:false
        }

        console.log(`name=${obj.name}, age=${obj.age}, gender=${obj.gender}`)
        // 输出：
        // name=testName, age=20, gender=false

        // 2. 输出函数调用结果
        let foo = ()=> "abcd"
        console.log(`result = ${foo()}`)
        // 输出:

        // 3. 模板字符串保留空格和换行
        let str = `
            1111
            2222
            3333`
        console.log(str)
        ```

## 对象的简写方式
[top](#catalog)
- 省略的内容
    1. **与变量同名的属性**可以省略，直接写变量名即可
    2. 方法的 `function` 关键字可以省略
- 示例
    - 参考代码
        - [src/es6/object/simple.html](src/es6/object/simple.html)
    - 代码内容
        ```js
        let name = "myname"
        let age = 25
        let obj = {
            name,
            age,
            show(){ // 省略原始的写法  show: function(){...}
                console.log(`name = ${this.name}, age = ${this.age}`)
            }
        }

        obj.show() // name = myname, age = 25
        ```

## 箭头函数
[top](#catalog)
- 用途：**定义匿名函数**
    - 虽然是匿名函数，但是可以用**函数表达式**的形式将函数赋值给变量，来复用
- 语法
    - 不同数量参数的函数声明方式
        - 无参函数：`() => 语句/表达式/{代码块}`
        - 一参函数：
            - `p => 语句/表达式/{代码块}`，推荐使用
            - `(p) => 语句/表达式/{代码块}`
        - 多数函数： `(a, b) => 语句/表达式/{代码块}`

    - 语句、表达式、代码块的写法
        - 如果函数体只有一行或表达式时，则不需要使用 `{}` 包裹，并且**表达式的结果作为函数返回值**
        - 如果函数体有多行，则必须按照正常的函数写法来编写，如果有返回值需要手动返回

- 箭头函数的特点
    1. 声明简洁
    2. <span style="color:red">箭头函数没有自己的 `this`</span>
        - 箭头函数的 this 不是在函数调用时决定的，而是在**定义时**决定的
        - 箭头函数定义在哪个对象中，this 就是那个对象
        - 如果在全局作用域声明箭头函数，则 this 是 window 对象

- 箭头函数中 this 对象的区分方法
    - 如果 箭头函数外层还有函数，则 this 是外层的函数所属的 this
        - 如果外层函数也是箭头函数，则继续向外层查找，直到 window对象
    - 如果 箭头函数外层没有函数，则 this 是 window

- 箭头函数的应用
    - 多用于回调函数

- 示例
    - 参考代码
        - [src/es6/function/arrow.html](src/es6/function/arrow.html)
    - 代码内容
        1. 参数的数量
            ```js
            // 1.1 无参函数
            let fn0101 = () => console.log("this is fn0101")
            fn0101()
            // 输出: this is fn0101

            // 1.2 一个参数
            let fn0102 = a => console.log(`a = ${a}`)
            fn0102("testStr")
            // 输出: a = testStr

            // 1.3 多个参数
            let fn0103 = (a, b) => a + b
            let result0103 = fn0103(3,6)
            console.log(`result0103 = ${result0103}`)
            // 输出: result0103 = 9
            ```
        2. 箭头函数的this
            ```js
            // 2.1 在全局作用域中定义箭头函数
            let fn0201 = () => console.log(this)
            fn0201()
            // 输出: Window {parent: Window, …}

            // 2.2 在全局作用域的函数内部定义箭头函数
            function fn0202(){
                // 外层函数属于 window，所以箭头函数的this仍然是 window
                let f = ()=>console.log(this)
                f()
            }
            fn0202()
            // 输出: Window {parent: Window, …}

            // 2.3 在对象函数的内部定义箭头函数
            let obj = {
                name:'objName',
                age:23,
                show(){
                    let f = () => console.log(this)
                    f()
                }
            }
            obj.show()
            // 输出: {name: "objName", age: 23, show: ƒ}

            // 2.4 箭头函数的外层函数还是箭头函数
            let obj0201 = {
                name:'obj2Name',
                age:26,
                show: ()=>{ // 外层函数仍然是箭头函数
                    let f = () => console.log(this)
                    f()
                }
            }
            obj0201.show()
            // 输出: Window {parent: Window, …}
            ```

## 展开运算符与函数的剩余参数
[top](#catalog)
- 展开运算符: `...`
- 展开运算符的功能
    - 普通展开
        - 放在可迭代对象前，将操作数展开为一组值
        - 放在普通对象前，将对象展开为一组属性
    - 在函数的参数声明中展开数组（可迭代对象）
        - 展开为参数
- 展开运算符的基本使用
    - 在数组使用通过展开运算符，可自动遍历其他数组，并将元素添加到新数组中
        ```js
        let a = [1,2,3]
        let b = [1, ...a, 6]
        ```
    - 在展开赋值时，捕获多余的参数
        ```js
        let [a, b, ...more] = [3, 4, 5, 6, 7, 8]
        ```
    - 展开对象，作为另一个对象的属性和属性值
        ```js
        var a = {name:'aaaa', age:22}
        var b = {address:'bbbbb', ...a}  // 展开对象
        // b = { address: 'bbbbb', name: 'aaaa', age: 22 }
        ```
- 函数的剩余参数---数组类型参数的展开
    - 剩余参数的用途
        - 用来取代 arguments对象，但是比 arguments 更加灵活
            - argument是类数组对象，rest是数组数组对象，可以使用 Array 上的方法
        - 可变参数**只能放在**函数**参数的最后**
    - 展开的基本形式
        ```js
        function 函数名(参数1, ...剩余参数){}
        ```
    - 展开时，只捕获部分参数
        ```js
        function 函数名(参数1, ...[a, b]){}
        ````

- 示例
    - 参考代码
        - [src/es6/function/rest_param.html](src/es6/function/rest_param.html)

    - 代码内容
        1. 展开运算
            ```js
            // 1.1 展开数组
            let a = [1, 2, 3]
            let b = [1, ...a, 6]
            console.log(b)
            // 输出: 
            // (5) [1, 1, 2, 3, 6]

            // 1.2 展开对象
            let o1 = {name:'aaaa', age:22}
            var o2 = {address:'bbbbb', ...o1}  // 展开对象
            console.log(o2);    // 输出: {address: "bbbbb", name: "aaaa", age: 22}
            ```
        2. 剩余参数
            ```js
            // 2. 函数的剩余参数
            // 2.1 展开的基本形式
            function restFn01(a, b, ...more){
                console.log(a)
                console.log(b)
                console.log(more)
            }
            restFn01(2,3,4,5,6);
            // 输出:
            // 2
            // 3
            // [4, 5, 6]
            
            // 2.2 展开时，只捕获部分参数
            function restFn02(a, b, ...[r1, r2]){
                console.log(a)
                console.log(b)
                console.log(r1)
                console.log(r2)
            }
            restFn02(2,3,4,5,6);
            // 输出:
            // 2
            // 3
            // 4
            // 5
            ```


## 形参默认值
[top](#catalog)
- 在声明函数时，为参数赋值。创建实例对象时，如果没有传参，则使用默认值
    ```js
    function Point(x=0, y=0){
        this.x = x
        this.y = y
    }
    let a = new Point();        // 使用默认值
    let b = new Point(1, 2);    // 使用自定义参数
    ```
- 默认参数最好放在最后声明
    ```js
    function Point(x, y=0){
        this.x = x
        this.y = y
    }
    let a = new Point(1);       // 使用默认值
    let b = new Point(1, 2);    // 使用自定义参数
    ```
- 如果默认参数被放在中间，在调用时，传递 `undefined` 来使用默认值
    ```js
    function Point(x=0, y){
        this.x = x
        this.y = y
    }
    let a = new Point(undefined, 1);    // 使用默认值
    let b = new Point(1, 2);            // 使用自定义参数
    ```

## Promise对象
### Promise对象说明
[top](#catalog)
- 什么是 `Promise对象`？
    - 一种异步编程的解决方案
        - `Promise对象` 代表了未来某个将要发生的事件，通常是一个异步操作
        - 有了 `Promise对象`，可以用同步的编码方式来处理异步操作，避免多层嵌套的回调函数
    - ES6 中的 `Promise对象` 是一个构造函数，用来生成 Promise实例

- 异步处理的场景--网络请求
    - 请求的发送与异步相应过程
        1. 封装网络请求函数，并执行
        2. 因为不能立即返回结果，所以会在调用时传入另一个回调函数
        3. 当请求返回时，调用回调函数，处理返回的数据
    - 对于简单的网络请求，使用回调函数比较容易
    - 当网络请求比较复杂时，可能会产生多层嵌套的回调，此时可以使用 `Promise` 来处理

- Promise对象的三种状态
    1. pending，等待状态
    2. resolved，成功状态
    3. rejected，失败状态

### Promise对象的使用方法
[top](#catalog)
- 创建Promise对象
    - `new Promise((resolve, reject)=>{...})`
    - 传入的回调函数
        - 需要有两个参数: `resolve`、`reject`
        - 在函数中进行初始化，将状态修改为 `pending`
        - <span style='color:red'>函数的执行是同步的，不会作为回调函数使用</span>
        - 函数内部的异步操作，仍然是异步的
    - 在函数内部调用异步操作，并通过 resolve、reject 来修改 Promise对象的状态
    - 如果没有调用 resolve、reject，则 Promise对象的状态将一直是 `pending`

- 修改 `Promise对象` 的状态
    - `resolve(data)`
        - 异步任务成功 时执行
        - 修改promise的状态为`resolved`
        - 通过data参数向外部传值
    - `reject(data)`
        - 异步任务失败 时执行
        - 修改promise的状态为`rejected`
        - 通过data参数向外部传值

- 异步处理的方法
    - `then()`
        - 功能响应正常的异步处理
        - 处理方式方式
            ```js
            new Promise(...).then(
                data=>{...},    // resolved 状态的响应函数, 执行 resolve(data) 后触发
                error=>{...}    // rejected 状态的响应函数, 执行 reject(error) 后触发
            )
            ```
        - 响应的触发条件
            - Promise对象的状态从 `pending` 变为 `resolved` 或 `rejected`
                - 即: 在`Promisie对象`中主动调用 `resolve()` 或 `reject()`
            - 如果 `Promise对象` 的状态将一直是 `pending`，将会一直等待
        - 一般开发中，不会将 `rejected`状态 的响应写在 `then()` 中，会通过 `catch()` 来处理

    - `catch()`，捕获 `reject` 的异常

- 解构嵌套的异步调用，并处理异常
    - 解构方式
        - 通过 `then()`、`catch()` 的链式调用，用同步式的代码来解构嵌套回调
    - <span style='color:red'>如何完成链式调用？</span>
        - 在每一层解构出来的嵌套中，创建并返回新的 `Promise对象`
    - 基本写法
        ```js
        new Promise( (resolve, reject) =>{
            ...
        }).then( data=>{
            //... 业务处理
            // 创建新的 Promise 对象，相当于第一层嵌套
            return new Promise((resolve, reject) =>{...});
        }).then( data=>{
            //... 业务处理
            // 创建新的 Promise 对象，相当于第二层嵌套
            return new Promise((resolve, reject) =>{...});
        }).catch( error=>{
            // 异常处理
        });
        ```
    - `catch()`，捕获到异常后的执行顺序
        - `catch()` 前面没有执行的 `then()` 会被忽略
        - `catch()` 内部如果返回了新的 `Promise对象`，则后面的 `then` 将会继续执行。否则整个链式调用会停止
            ```js
            new Promise( (resolve, reject) =>{
                ...             //<<<<<<< 1. 执行异步操作
            }).then( data=>{
                return new Promise((resolve, reject) =>{
                    reject()    //<<<<<<< 2. 抛出异常
                });
            }).then( data=>{
                return new Promise((resolve, reject) =>{
                    resolve()   //<<<<<<< 上一个执行抛出了异常，将被跳过
                });
            }).catch( error=>{
                // 异常处理     //<<<<<<< 3. 捕获异常
                return new Promise((resolve, reject) =>{
                    resolve()   //<<<<<<< 4. 继续执行
                });
            }).then(data=>{
                ...             //<<<<<<< 5. 继续执行，响应的是上面的 catch 中返回的 Promise对象
            });
            ```

- 示例
    - 基本使用
        - 参考代码
            - [src/es6/promise/base.html](src/es6/promise/base.html)
        - 代码内容
            ```js
            let promise = new Promise((resolve, reject)=>{
                // 初始化promise， 状态：pending
                console.log("promise init start")

                // 执行异步操作，通常是发送ajax请求、开启定时器
                setTimeout(()=>{
                    console.log("promise inner timer")
                    let data = "timer data"
                    // 根据异步任务的返回结果去修改promise的状态
                    // 异步任务成功
                    resolve(data) //修改promise的状态为resolved
                    // 异步任务失败
                    // reject(data) //修改promise的状态为rejected
                }, 2000)
            })

            console.log("promise init end")

            promise.then(
                data=>console.log("success " + data),  // 成功的回调
                error=>console.log("failure " + error)   // 失败的回调
            )

            console.log("promise end")

            // 输出:
            // promise init start
            // promise init end
            // promise end
            // promise inner timer
            // success timer data
            ```
    - 解构多层嵌套的回调
        - 参考代码
            - [src/es6/promise/nest_promise.html](src/es6/promise/nest_promise.html)
        - 代码内容
            ```js
            new Promise((resolve, reject) => {
                setTimeout(() => {
                    resolve();
                }, 1000);   // 延迟1s，模拟异步操作
            }).then(data => {
                // 第 1 层嵌套
                console.log('nest 1');

                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve();
                    }, 1000);   // 延迟1s，模拟异步操作
                });
            }).then(data => {
                // 第 2 层嵌套
                console.log('nest 2');

                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve();
                    }, 1000);   // 延迟1s，模拟异步操作
                });
            }).then(data => {
                // 第 3 层嵌套
                console.log('nest 3');
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        reject('out from nest3');   // 手动创建一个异常
                        // resolve();
                    }, 1000);   // 延迟1s，模拟异步操作
                });
            }).then(data => {
                // 第 4 层嵌套
                console.log('nest 4');
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve();
                    }, 1000);
                });
            }).catch(error => {
                // 处理异常
                console.log(`err = ${error}`);
                // 创建新的异步请求
                return new Promise((resolve, reject) => {
                    setTimeout(() => {
                        resolve('catch error data');
                    }, 1000);
                });
            }).then(data => {
                // 第 5 层嵌套
                console.log(`nest 5: ${data}`);
            });

            /* 输出:
                nest 1
                nest 2
                nest 3
                err = out from nest3
                nest 5: catch error data

                因为在第 3 层出现了异常，被 catch捕获了，所以不会执行第4层嵌套
                catch 中，又返回了新的 Promise对象，所以会继续执行第5层
            */
            ```

### 简化只有数据的Promise对象
[top](#catalog)
- 简化的条件
    - Promise 中只有数据，没有逻辑处理
    - 在链式调用中，为了完成后续的链式调用，必须要返回一个 `Promise对象`
        - 即使只有同步代码，也要返回 `Promise对象`，否则链式调用会停止

- 通过 `Promise` 的静态方法实现简写
    - 静态方法
        - `Promise.resolve(data)`
            - data的类型
                - 基本数据类型
                - 另一个 Promise对象
                - `thenable` ?????
            - 返回值
                - Promise对象
                - 如果 data 是另一个 Promise对象，则不做封装，直接返回该对象
        - `Promise.reject(error)`
            - error的类型
                - `Error()` 构造函数的示例
                - 基本数据类型
            - 返回值
                - Promise对象
    - 简化过程
        - 简化前
            ```js
            new Promise( (resolve, reject) =>{
                ...             //<<<<<<< 1. 执行异步操作
            }).then( data=>{
                return new Promise((resolve, reject) =>{
                    resolve()   //<<<<<<< 2. 继续执行
                });
            }).then( data=>{
                return new Promise((resolve, reject) =>{
                    reject()    //<<<<<<< 3. 抛出异常
                });
            }).catch( error=>{
                // 异常处理     //<<<<<<< 3. 捕获异常
                return new Promise((resolve, reject) =>{
                    resolve()   //<<<<<<< 4. 继续执行
                });
            }).then( data=>{
                ....
            });
            ```
        - 简化后
            ```js
            new Promise( (resolve, reject) =>{
                ...             //<<<<<<< 1. 执行异步操作
            }).then( data=>{
                return Promise.resolve(...);    //<<<<<<< 2. 继续执行
            }).then( data=>{
                return Promise.reject(...);    //<<<<<<< 3. 抛出异常
            }).catch( error=>{
                // 异常处理     //<<<<<<< 3. 捕获异常
                return Promise.resolve(...);   //<<<<<<< 4. 继续执行
            }).then( data=>{
                ....
            });
            ```

- 使用 `return` 和 `throw` 进一步简化
    - 两个语句的简化关系
        - `return data` 简化 `Promise.resolve(data);`
        - `throw error` 简化 `Promise.reject(error);`
    - 数据返回、异常抛出时，Promise底层会封装成 Promise对象
    - 简化过程
        - 简化前
            ```js
            new Promise( (resolve, reject) =>{
                ...             //<<<<<<< 1. 执行异步操作
            }).then( data=>{
                return Promise.resolve(...);    //<<<<<<< 2. 继续执行
            }).then( data=>{
                return Promise.reject(...);    //<<<<<<< 3. 抛出异常
            }).catch( error=>{
                // 异常处理     //<<<<<<< 3. 捕获异常
                return Promise.resolve(...);   //<<<<<<< 4. 继续执行
            }).then( data=>{
                ....
            });
            ```
        - 简化后
            ```js
            new Promise( (resolve, reject) =>{
                ...             //<<<<<<< 1. 执行异步操作
            }).then( data=>{
                return ...;     //<<<<<<< 2. 继续执行
            }).then( data=>{
                throw ...;      //<<<<<<< 3. 抛出异常
            }).catch( error=>{
                // 异常处理     //<<<<<<< 3. 捕获异常
                return ...;     //<<<<<<< 4. 继续执行
            }).then( data=>{
                ....
            });
            ```

- 示例
    - 参考代码
        - [src/es6/promise/simple_promise.html](src/es6/promise/simple_promise.html)
    - 使用 return、throw 来简化只有同步代码的Promise对象
        ```js
        new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve('nest1');
            }, 1000);   // 延迟1s，模拟异步操作
        }).then(data => {
            // 第 1 层嵌套
            console.log(data);
            return 'nest2';
        }).then(data => {
            // 第 2 层嵌套
            console.log(data);
            return 'nest3';
        }).then(data => {
            // 第 3 层嵌套
            console.log(data);

            // return Promise.resolve('nest4');
            throw 'error from nest3';   // 抛出一个异常
        }).then(data => {
            // 第 4 层嵌套
            console.log(data);
            return 'nest5';
        }).catch(error => {
            // 处理异常
            console.log(error);
            // 创建新的Promise对象
            return 'catch error data';
        }).then(data => {
            // 第 5 层嵌套
            console.log(`nest 5: ${data}`);
        });

        /* 输出:
            nest 1
            nest 2
            nest 3
            error from nest3
            nest 5: catch error data
        */
        ```

### Promise.all--等待所有异步调用完成
[top](#catalog)
- `Promise.all(iterator)`
    - 参数 iterator
        - 需要是一个可迭代对象，包括: `Array`、`String`
        - 迭代对象内部可以包含: Promise对象、普通数据类型
    - 返回值

        |参数内容|返回值|
        |-|-|
        |iterator是空对象|一个 `resolved` 状态的 Promise对象|
        |iterator中不包含 Promise对象|一个 `resolved` 状态的 Promise对象|
        |iterator中包含 Promise对象|一个 `pending` 状态的 Promise对象|
    - Promise对象整体的状态
        - 所有Promise对象都变成 `resolved` 状态，则整体为 `resolve` 状体
        - 当有一个 Promise对象变成 `rejected` 状态时，立刻将整体设为 `rejected` 状态，并忽略未完成的异步操作
- 异步结束后，返回的数据
    - 当整体为 `resolve` 状态
        - 永远都会返回一个数组
        - 数组中元素的顺序 与 参数iterator中的顺序相同
    - 当整体为 `rejected` 状态
        - 返回 `rejected` 状态的 Promise对象的数据
- 示例
    - 参考代码
        - [src/es6/promise/all.html](src/es6/promise/all.html)
    - 代码内容
        1. 全部 Promise对象是 resolved 状态
            ```js
            Promise.all([
                new Promise((resolve, reject)=>{
                    setTimeout(()=>resolve(2), 2000);
                }),
                new Promise((resolve, reject)=>{
                    setTimeout(()=>resolve('abcd'), 1000);
                })
            ]).then(data=>{
                console.log(data);  // 输出: [2, "abcd"]
            })
            ```
        2. 存在 Promise对象是 rejected 状态
            ```js
            Promise.all([
                new Promise((resolve, reject)=>{
                    setTimeout(()=>reject(2), 2000);
                }),
                new Promise((resolve, reject)=>{
                    setTimeout(()=>resolve('abcd'), 1000);
                })
            ]).then(data=>{
                console.log(data);
            }).catch(error=>{
                console.log(`error = ${error}`);    // 输出: error = 2
            })
            ```

## Symbol属性
[top](#catalog)
- ES5中对象的属性名都是字符串，容易造成重名，污染环境
- 什么是Symbol？
    - ES6中添加的一种原始数据类型
    - 与其他数据类型：String、Number、Boolean、Null、Undefined、Object 的地位相同
- Symbol的特点
    - Symbol属性值是**唯一**的，可以解决命名冲突的问题
    - Symbol值不能与其他数据进行运算，包括进行字符串拼接
    - `for in`, `for of` 遍历时不会遍历symbol属性

- 内置Symbol值
    - ES6提供了11个内置的Symbol值，执行语言内部使用的方法

- 示例
    - 参考代码
        - [src/es6/symbol/base.html](src/es6/symbol/base.html)
    - 代码内容
        ```js
        // 1. 创建Symbol属性
        let symbol = Symbol();
        console.log(symbol)
        // 输出: Symbol()

        // 2. Symbol值做对象属性
        let obj = {name:"testName", age:22}
        obj[symbol] = "hello"
        console.log(obj)
        // 输出: {name: "testName", age: 22, Symbol(): "hello"}

        for(let p in obj){
            console.log(p)
        }
        // 输出:
        // name
        // age

        // 3. Symbol值的比较
        let a = Symbol()
        let b = Symbol()
        console.log(a === b)
        // 输出: false
        console.log(a, b)
        // 输出: Symbol() Symbol()

        // 4. 创建Symbol时，注入标识
        let c = Symbol("12")
        let d = Symbol("23")
        console.log(c === d)
        // false
        console.log(c, d)
        // 输出: Symbol(12) Symbol(23)

        // 5. 定义Symbol常量
        const key = Symbol("key")
        console.log(key)
        // 输出: Symbol(key)
        ```

## Iterator迭代器接口
### Iterator的概念与使用方法
[top](#catalog)
- Iterator的作用
    1. 为各种数据结构提供一个统一的、简便的访问接口
    2. 使数据结构的成员能按某种次序排列

- 使用场景
    - ES6中的新遍历方式 `for of`，Iterator接口主要供 `for of` 遍历使用
    - 展开运算符，底层使用Iterator接口遍历
    - 展开赋值，底层使用Iterator接口遍历

- 内置的已支持Iterator的数据类型
    1. String
    2. Array
    3. arguments
    4. set容器
    5. map容器

- 示例
    - 参考代码
        - [src/es6/iterator/base.html](src/es6/iterator/base.html)
    - 遍历内置的已部署Iterator的数据类型
        ```js
        // 1.1 String
        let str = "asdfg"
        for(let n of str){
            console.log(n)
        }
        // 输出：
        // a
        // s
        // d
        // f
        // g

        // 1.2. Array
        let arr = ["aaa", "bbb", "ccc", "ddd"]
        for(let n of arr){
            console.log(n)
        }
        // 输出：
        // aaa
        // bbb
        // ccc
        // ddd

        // 1.3. arguments
        function foo(){
            for(let n of arguments){
                console.log(n)
            }
        }
        foo(1, 2, 3, 4, "dd", "ff")
        // 输出：
        // 1
        // 2
        // 3
        // 4
        // dd
        // ff

        // 1.4 无法遍历对象
        let obj = {name:"testName", age:22}
        // TypeError: obj is not iterable
        // for(let n of obj){
        //     console.log(n)
        // }
        ```

### Iterator的工作原理与自定义实现
[top](#catalog)
- 自定义语法
    - 为对象添加 `[Symbol.iterator]` 方法
    - 该方法返回一个包含 `next()` 方法的对象
    - 示例
        ```js
        {
            [Symbol.iterator]: function(){
                return {
                    next: function(){...}
                }
            }
        }
        ```

- Iterator的执行流程
    1. 调用对象的 `[Symbol.iterator]` 方法
    2. 调用方法之后创建一个指针对象（遍历器对象），对象内部包含一个 `next()`方法，指向数据结构的起始位置
    3. 调用 `next` 方法，指针自动指向数据结构的第一个元素
    4. 继续调用 `next` 方法，直到最后一个元素

- `next`方法的返回结果
    - 调用 `next` 方法后，返回一个对象：`{value: 当前成员的值, done:布尔值}`
        - 遍历结束时，返回：`{value:undefined, done:true}`
        - 遍历未结束时，返回：`{value:当前元素, done:false}`
    - value，表示当前元素的值
    - done，表示当前对象是否遍历结束

- 使用 `for of` 遍历时的执行流程
    - 搜索对象的 `[Symbol.iterator]` 方法
    - 如果没有则报错
    - 如果有则调用方法，然后开始迭代

- 示例
    - 参考代码
        - [src/es6/iterator/myIterator.html](src/es6/iterator/myIterator.html)
     - 代码内容
        1. iterator原理
            ```js
            // 模拟指针对象--遍历器对象
            function MyIterator(arr){
                //也可以使用闭包
                return {
                    arr,
                    index:  0,
                    length: arr.length,
                    next(){
                        if (this.index < this.length){
                            return {value: this.arr[this.index++], done:true}
                        } else {
                            return {value: undefined, done:false}
                        }
                    }
                }
            }
            let iter = MyIterator(["a","b","t","c"])
            console.log(iter.next())
            console.log(iter.next())
            console.log(iter.next())
            console.log(iter.next())
            console.log(iter.next())
            ```
        2. 自定义数组迭代器
            ```js
            function ArrayIterator(arr){
                // 创建对象
                return {
                    // for of 遍历执行后，调用该方法，返回一个包含 next() 的对象
                    [Symbol.iterator](){
                        return {
                            arr,
                            index:0,
                            length:arr.length,
                            next(){
                                if (this.index < this.length){
                                    return {value: this.arr[this.index++], done:false}
                                } else {
                                    return {value: undefined, done:true}
                                }
                            }
                        }
                    }
                }
            }

            let arrayIter = ArrayIterator([1,2,"t",4,5]);
            for(let n of arrayIter){
                console.log(n)
            }
            ```
        3. 自定义对象迭代器
            ```js
            // type=true ,遍历value
            // type != false, 遍历key
            function ObjIterator(obj, type=true){
                // 创建对象
                return {
                    // for of 遍历执行后，调用该方法，返回一个包含 next() 的对象
                    [Symbol.iterator](){
                        let datas = type === true? Object.values(obj) : Object.keys(obj)
                        let length = datas.length
                        return {
                            index:0,
                            datas,
                            length,
                            next(){
                                if (this.index < this.length){
                                    return {value:this.datas[this.index++], done:false}
                                }else {
                                    return {value:undefined, done:true}
                                }
                            }
                        }
                    }
                }
            }

            let obj={name:"testName", age:22, gender:false}
            let objIter = ObjIterator(obj)
            for(let p of objIter){
                console.log(p)
            }
            ```

## Generator函数
### Generator函数与使用方法
[top](#catalog)
- 什么是Generator函数?
    - ES6提供的异步编程方案之一，比Promise对象更加方便
    - Generator函数是一个状态机，内部封装了不同状态的数据
    - 可以生成 `Iterator` 对象

- Generator函数的用途
    - 生成 `Iterator` 对象
    - 暂停函数的执行--惰性求值

- Generator函数的缺点
    - 通过 `next()` 方法来启动和执行，仍然没有脱离回调函数

- 语法
    ```js
    function* 函数名(){
                                    //<---- 第一次调用开始位置
        // 处理逻辑
        let result = yield 表达式   //<---- 第一次调用停止位置
        // 使用result               //<---- 第二次调用停止位置
        ...                         // .....
        ...
    }

    // 1. 创建Generator对象
    let obj = 函数名()
    // 2. 开始执行函数，到 yield处停止
    obj.next()
    // 3. 继续执行函数，并且可以选择为函数内部的 result 变量赋值
    // obj.next() // 直接调用，不为函数内部的result赋值
    obj.next(result的值)
    ```

- Generator函数的特点
    - 用 `function*` 来定义
    - 执行函数后，返回一个 `Iterator` 对象
    - 内部使用 `yield` 表达式定义不同的状态
    - 通过 `next()` 方法执行
    - 遇到 `yield` 表达式时，执行表达式并结果作为 `next()`方法的返回结果，然后**暂停函数**
    - 在函数内部，yield表达式的返回结果默认为undefined，可以在**下一次**调用时，通过 `next(参数)` 的方式，为其赋值

- Generator对象的执行流程
    1. 调用Generator函数，返回一个 `Iterator` 对象
        - 只创建对象，不会执行内部函数的逻辑
    2. 第一次调用 `next()` 方法，开始执行函数逻辑
    3. 执行时遇到 `yield` 表达式后，执行 `yield` 表达式并返回执行结果，然后**暂停函数**
    4. 继续调用 `next()` 方法，从上一次 `yield` 停止处继续执行函数
    5. 然后重复执行 3、4 直到函数结束
    6. 函数结束时，返回: `{value: undefined, done: true}`
    7. 函数执行结束后，仍然可以继续调用 `next()`，不会报错，但是返回的一直都是: `{value: undefined, done: true}`

- 示例
    - 参考代码
        - [src/es6/generator/base.html](src/es6/generator/base.html)

    - 代码内容
        ```js
        function* MyGenerator(){
            console.log("generator start")

            yield console.log("first")

            let result01 = yield "aaaaa"
            console.log("result01 =" + result01)

            let result02 = yield "bbbbb"
            console.log("result02 =" + result02)

            console.log("generator end")
        }

        let g = MyGenerator()
        console.log(g)

        console.log("create")
        console.log(g.next())
        console.log(g.next())
        console.log(g.next(3333))
        console.log(g.next())
        console.log(g.next())

        // 输出:
        // MyGenerator {<suspended>}
        // create               <-------创建函数时，并没有执行
        // create
        // generator start
        // first
        // {value: undefined, done: false}
        // {value: "aaaaa", done: false}
        // result01 =3333
        // {value: "bbbbb", done: false}
        // result02 =undefined
        // generator end
        // {value: undefined, done: true}
        // {value: undefined, done: true}
        ```

### 通过Generator函数创建自定义迭代器
[top](#catalog)
- 自定义方法
    - `obj[Symbol.iterator] = function*(){...}`
    - 添加 `[Symbol.iterator]` 方法，并且通过 `function*` 来定义方法

- 示例
    - 参考代码
        - [src/es6/generator/iterator.html](src/es6/generator/iterator.html)

    - 代码内容
        ```js
        // 遍历对象所有的属性值
        let obj = {name:"testName", age:22, gender:true}
        obj[Symbol.iterator] = function*(){
            for (let k in this){
                yield this[k]
            }
        }

        for (let v of obj){
            console.log(v)
        }
        ```

## class
[top](#catalog)
- class 的用途
    - 定义类
    - 实现类的继承

- 使用方法
    - 通过 `constructor()` 函数定义构造方法
    - 使用 `new` 关键字来创建实例对象
    - 通过 `extends` 关键字实现类的继承
    - 通过 `super()` 调用父类的 **构造方法**
    - 通过 `super.方法名` 调用父类的 **构造方法**
    - 可以重写从父类中继承的 **一般方法**
    - **声明方法时，必须使用简写形式**

- class中的方法最终添加在哪?
    - class中的方法默认都会添加到原型对象中

- 继承的原理
    - 子类的原型指向父类，父类的原型指向空Ojbect对象
    - 继承本质上与组合方式实现继承相似，即 call父类构造函数 + 原型设置

- 示例
    - 参考代码
        - [src/es6/class/base.html](src/es6/class/base.html)
        
    - 代码内容
        1. class 定义类，与函数定义类 生成的实例对象的区别
            ```js
            class Person{
                constructor(name, age){
                    this.name = name
                    this.age = age
                }
            }

            function Person02(name, age){
                this.name = name
                this.age = age
            }

            let p = new Person("testName", 22)
            let p02 = new Person02("name02", 23)

            console.log(p)
            console.log(p02)

            // 输出内容：
            // Person {name: "testName", age: 22}
            //     age: 22
            //     name: "testName"
            //     __proto__:
            //         constructor: class Person  <---原型对象的构造器不同
            //         __proto__: Object


            // Person02 {name: "name02", age: 23}
            //     age: 23
            //     name: "name02"
            //     __proto__:
            //         constructor: ƒ Person02(name, age) <---原型对象的构造器不同
            //         __proto__: Object

            ```
        2. 函数的一般方法
            ```js
            class Person03{
                constructor(name, age){
                    this.name = name
                    this.age = age
                }

                showSelf(){
                    console.log(`name = ${this.name}, age = ${this.age}`)
                }
            }

            let p03 = new Person03("testName03", 24)
            // console.log(p03)
            p03.showSelf()
            // 输出: name = testName03, age = 24
            ```
        3. 类的继承
            ```js
            class Student extends Person03{
                constructor(name, age, price){
                    // 调用父类的构造函数
                    super(name, age)
                    // 添加子类的内容
                    this.price = price
                }
                // 重写父类的方法
                showSelf(){
                    super.showSelf()
                    console.log(`name = ${this.name}, age = ${this.age}, price = ${this.price}`)
                }
            }

            let student = new Student("aaa", 11, 90)
            student.showSelf()
            // 输出
            // name = aaa, age = 11
            // name = aaa, age = 11, price = 90

            // 检查类的结构
            console.log(student)
            // Student {name: "aaa", age: 11, price: 90}
            //     age: 11
            //     name: "aaa"
            //     price: 90
            //     __proto__: Person03
            //         constructor: class Student
            //         showSelf: ƒ showSelf()
            //         __proto__:
            //             constructor: class Person03
            //             showSelf: ƒ showSelf()
            //             __proto__: Object
            ```

## String扩展
[top](#catalog)

|方法|功能|
|-|-|
|includes(str)|判断是否包含指定的字符串|
|startswith(str)|判断是否以指定字符串开头|
|endswith(str)|判断是否以指定字符串结尾|
|repeat(count)|重复指定次数，并返回一个新的字符串|

## Number扩展
[top](#catalog)
- 二进制数表示法：`0b10101`
- 八进制数表示法：`0o1234567`
- 扩展函数

    |方法|功能|备注|
    |-|-|-|
    |Number.isFinite(i)|判断是否是**有限大的数**|可以省略Number，直接调用|
    |Number.isNaN(i)|判断是否为NaN|可以省略Number，直接调用|
    |Number.isInteger(i)|判断是否是整数||
    |Number.parseInt(str)|将字符串转化为数值|可以省略Number，直接调用|
    |Math.trunc(i)|去除小数部分||

## ES6-Array扩展
[top](#catalog)
- 扩展方法

    |方法|功能|
    |-|-|
    |Array.from(v)|将伪数组对象、可遍历对象转换为真数组|
    |Array.of(v1, v2, v3,...)|将多个值转换为数组|
    |find( function(value, ndex, arr){return true} )|找出第一个返回true的元素|
    |findIndex( function(value, ndex, arr){return true} )|找出第一个返回true的元素的下标|

- 示例
    - 参考代码
        - [src/es6/array/extends.html](src/es6/array/extends.html)
    - 代码内容
        ```js
        // 1. 将伪数组对象、可遍历对象转换为真数组
        let buttons = document.getElementsByTagName("button")
        let arr01 = Array.from(buttons)
        console.log(buttons)
        // 输出: HTMLCollection(3) [button, button, button]
        console.log(arr01)
        // 输出: (3) [button, button, button]

        // 报错
        // buttons.forEach((item)=>console.log(item))
        arr01.forEach((item)=>console.log(item))
        // 输出:
        // <button>​btn1​</button>​
        // <button>​btn2​</button>​
        // <button>​btn3​</button>​

        // 2. 将多个值转换为数组
        let arr02 = Array.of("aa", "bbb","cc")
        console.log(arr02)
        // 输出: (3) ["aa", "bbb", "cc"]

        // 3. 找出第一个返回true的元素
        let arr03 = [2, 4, 6, 8]
        let result03 = arr03.find(item=>item>5)
        console.log(result03)
        // 输出: 6

        // 4. 找出第一个返回true的元素的下标
        let arr04 = [2, 4, 6, 8]
        let result04 = arr04.findIndex(item=>item>5)
        console.log(result04)
        // 输出: 2
        ```

## Object的扩展方法
[top](#catalog)
- 扩展方法

    |方法|说明|
    |-|-|
    |`Object.is(v1, v2)`|判断2个数据是否**完全相等**|
    |`Object.assign(target, source1, source2,...)`|将原对象的属性复制到目标对象|
    |||

- 可以直接操作对象的 `__proto__` 属性

- 示例
    - 参考代码
        - [src/es6/object/extends.html](src/es6/object/extends.html)
    - 代码内容
        ```js
        // 1. 比较两个数据是否相对
        // 1.1 0 与 -0 的比较
        console.log("0 == -0 :", 0 == -0)
        // 输出: 0 == -0 : true

        console.log("0 === -0 :", 0 === -0)
        // 输出: 0 === -0 : true

        console.log("Object.is(0, -0) =", Object.is(0, -0))
        // 输出: Object.is(0, -0) = false

        // 1.2 NaN 与 NaN的比较
        console.log("NaN == NaN :", NaN == NaN)
        // 输出: NaN == NaN : false

        console.log("NaN === NaN :", NaN === NaN)
        // 输出: NaN === NaN : false

        console.log("Object.is(NaN, NaN) =", Object.is(NaN, NaN))
        // 输出: Object.is(NaN, NaN) = true

        // 2. 将原对象的属性复制到目标对象
        let obj = {}
        let objx = {name:"testName", age:22}
        let objy = {gender:false, price: 90}
        console.log("before assign:", obj)
        // 输出: before assign: {}

        Object.assign(obj, objx, objy)
        console.log("after assign:", obj)
        // 输出: after assign: {name: "testName", age: 22, gender: false, price: 90}

        // 3. 直接操作对象的 __proto__ 属性
        let obj0301 = {}
        let obj0302 = {name:"name0302", age:33}
        obj0301.__proto__ = obj0302
        console.log(obj0301.name, obj0301.age)
        // 输出: name0302 33
        ```

## 拷贝
### 浅拷贝
[top](#catalog)
- 几种浅拷贝的方法
    1. `=` 赋值
        - 对于基本数据类型，值拷贝
        - 对于对象类型，地址拷贝
    2. `Object.assign(source)`，拷贝 source 的地址
    3. `Object.assign({}, source)`
        - 如果属性是基本数据类型，则进行值拷贝
        - 如果属性是对象类型，则进行地址拷贝
    4. `Array.prototype.concat()`
        - 如果属性是基本数据类型，则进行值拷贝
        - 如果属性是对象类型，则进行地址拷贝
    5. `Array.prototype.slice()`，不传参，直接拷贝整个数组
        - 如果属性是基本数据类型，则进行值拷贝
        - 如果属性是对象类型，则进行地址拷贝
- 示例
    - 参考代码
        - [src/es6/copy/shallow.html](src/es6/copy/shallow.html)

    - 代码内容
        1. `Object.assign(source)`
            ```js
            let obj0101 = {name:"testName", age:22, o:{price:99, address:"qwerty"}}

            obj0101.show = function(){
                console.log(`name = ${this.name}, age = ${this.age}, o.price = ${this.o.price}, o.price = ${this.o.address}`)
            }

            let obj0102 = Object.assign(obj0101)
            obj0101.show()
            // 输出: name = testName, age = 22, o.price = 99, o.price = qwerty
            obj0102.show()
            // 输出: name = testName, age = 22, o.price = 99, o.price = qwerty

            obj0101.name = "newName"
            obj0102.o.price = 60

            obj0101.show()
            // 输出: name = newName, age = 22, o.price = 60, o.price = qwerty
            obj0102.show()
            // 输出: name = newName, age = 22, o.price = 60, o.price = qwerty
            ```

        2. ` Object.assign({}, source)`
            ```js
            let obj0201 = {name:"testName", age:22, o:{price:99, address:"qwerty"}}

            obj0201.show = function(){
                console.log(`name = ${this.name}, age = ${this.age}, o.price = ${this.o.price}, o.price = ${this.o.address}`)
            }
            let obj0202 = {}
            Object.assign(obj0202, obj0201)
            obj0201.show()
            // 输出: name = testName, age = 22, o.price = 99, o.price = qwerty
            obj0202.show()
            // 输出: name = testName, age = 22, o.price = 99, o.price = qwerty

            obj0201.name = "newName"
            obj0202.o.price = 60

            // 修改基本数据类型属性不会影响原始对象，修改对象类型属性会影响原始对象
            obj0201.show()
            // 输出: name = newName, age = 22, o.price = 60, o.price = qwerty
            obj0202.show()
            // 输出: name = testName, age = 22, o.price = 60, o.price = qwerty
            ```

        3. `Array.prototype.concat()`
            ```js
            let arr0301 = [1, 2, 3, 4, {name:"arrName", age:60}]
            let arr0302 = arr0301.concat()
            console.log(arr0301)
            // 输出: (5) [1, 2, 3, 4, {name: "arrName", age: 60}]
            console.log(arr0302)
            // 输出: (5) [1, 2, 3, 4, {name: "arrName", age: 60}]

            // 修改基本数据类型属性不会影响原始数组，修改对象类型属性会影响原始数组
            arr0302[2] = "xxx"
            arr0302[4].name = "newName"
            console.log(arr0301)
            // 输出: (5) [1, 2, 3, 4, {name: "newName", age: 60}]
            console.log(arr0302)
            // 输出: (5) [1, 2, "xxx", 4, {name: "newName", age: 60}]
            ```

        4. `Array.prototype.slice()`
            ```js
            let arr0401 = [1, 2, 3, 4, {name:"arrName", age:60}]
            let arr0402 = arr0401.slice()
            console.log(arr0401)
            // 输出: (5) [1, 2, 3, 4, {name: "arrName", age: 60}]
            console.log(arr0402)
            // 输出: (5) [1, 2, 3, 4, {name: "arrName", age: 60}]

            // 修改基本数据类型属性不会影响原始数组，修改对象类型属性会影响原始数组
            arr0402[2] = "xxx"
            arr0402[4].name = "newName"
            console.log(arr0401)
            // 输出: (5) [1, 2, 3, 4, {name: "newName", age: 60}]
            console.log(arr0402)
            // 输出: (5) [1, 2, "xxx", 4, {name: "newName", age: 60}]
            ```

### 深拷贝-JSON转换
[top](#catalog)
- JSON转换实现深拷贝
    - 只能处理数组和对象，**不能拷贝函数**
- 示例
    - 参考代码
        - [src/es6/copy/deepByJSON.html](src/es6/copy/deepByJSON.html)

    - 代码内容
        ```js
        // 1. JSON转换
        let obj0101 = {
            name:"testName",
            age:22,
            show(){
                console.log(`name = ${this.name}, age = ${this.name}`)
            }
        }

        let obj0102 = JSON.parse(JSON.stringify(obj0101))
        console.log(obj0101)
        // 输出: {name: "testName", age: 22, show: ƒ}
        console.log(obj0102)
        // 输出: {name: "testName", age: 22} <--- 无法复制函数对象

        obj0101.name = "newName"
        console.log(obj0101)
        // 输出: {name: "newName", age: 22, show: ƒ}
        console.log(obj0102)
        // 输出: {name: "testName", age: 22}
        ```

### 深拷贝-自定义深拷贝实现
[top](#catalog)
- 深拷贝中的问题
    - 需要递归拷贝数据中的对象和数组
    - 所以只需要特殊处理对象与数组，基本数据类型和函数对象直接用 `=` 赋值
        - 基本对象进行值赋值
        - 函数对象与原始对象共享
- 实现方式
    1. 获取数据类型
        - 不使用 typeof来判断类型，因为无法区分普通对象与Null
        - 通过 `Object.prototype.toString.call(data)` 的方式，直接调用原型上的函数来获取类型，返回结果如下，对类型的区分度更高

            |类型|返回结果|
            |-|-|
            |Undefined| [object Undefined] |
            |Null| [object Null] |
            |Number| [object Number] |
            |String| [object String] |
            |Function| [object Function] |
            |Boolean| [object Boolean] |
            |Object| [object Object] |
    2. 如果是对象和数组则进行拷贝，如果不是，则直接返回数据
    3. 如果某个元素仍然是对象或数组，则进行递归拷贝

- 示例
    - 参考代码
        - [src/es6/copy/deepByCustome.html](src/es6/copy/deepByCustome.html)

    - 代码内容
        ```js
        // 检查数据类型
        function checkType(data){
            // [object xxxx] -->xxxx
            return Object.prototype.toString.call(data).slice(8, -1)
        }

        // 深拷贝
        function clone(data){
            let result, type = checkType(data)

            // 如果是 对象或数组，则进行深拷贝，其他类型直接返回
            if (type === "Object"){
                result = {}
            } else if (type === "Array"){
                result = []
            } else {
                return data
            }

            // 遍历对象或数组，通过key/index取值
            // 如果值仍然是对象或数组，则进行递归克隆
            for(let k in data){
                result[k] = clone(data[k])
            }

            return result
        }

        let obj = {
            name:"testName",
            age:22,
            price:{a:60, b:70, c:80 },
            address:null
        }

        let obj2 = clone(obj)

        console.log(obj)
        // {name: "testName", age: 22, price: {a: 60, b: 70, c: 80}, address: null}
        console.log(obj2)
        // {name: "testName", age: 22, price: {a: 60, b: 70, c: 80}, address: null}

        // 修改数据
        obj2.name = "newName"
        obj2.price.b = 100

        console.log(obj)
        // {name: "testName", age: 22, price: {a: 60, b: 70, c: 80}, address: null}
        console.log(obj2)
        // {name: "newName", age: 22, price: {a: 60, b: 100, c: 80}, address: null}
        ```

## set容器
[top](#catalog)
- 什么是set容器?
    - 无序不可重复的多个value的集合体
- 创建方法
    - 空set容器：
        ```js
        let set = new Set()
        ```
    - 使用可迭代对象（实现了iterator接口的对象）初始化set容器
        ```js
        let set = new Set([1,2,3,4,3,2,1])
        ```
- 应用场景
    - 数组去重
    - 保存唯一值

- 常用方法

    |方法|说明|
    |-|-|
    |size|getter属性，获取set中元素的个数|
    |add(value)|添加元素，如果已有则不添加|
    |has(value)|检查是否包含指定元素|
    |delete(value)|删除某个元素|
    |clear()|清空set|

- 示例
    - 参考代码
        - [src/es6/set/base.html](src/es6/set/base.html)

    - 代码内容
        ```js
        let set = new Set([1,2,3,4,3,2,1])
        set.add(10)
        set.add(1)

        console.log(set)
        // 输出: Set(5) {1, 2, 3, 4, 10}

        console.log(set.size)
        // 输出: 5

        console.log(set.has(7))
        // 输出: false
        console.log(set.has(1))
        // 输出: true

        set.delete(1)
        console.log(set)
        // 输出: Set(4) {2, 3, 4, 10}

        // 遍历
        for(let n of set){
            console.log(n)
        }
        // 输出: 2
        // 输出: 3
        // 输出: 4
        // 输出: 10

        set.clear()
        console.log(set)
        // 输出: Set(0) {}
        ```

## map容器
[top](#catalog)
- 什么是map容器？
    - 无序的key不重复的key-value集合

- 创建方法
    - 空map容器：
        ```js
        let set = new Map()
        ```
    - 使用二维数组初始化map容器
        ```js
        let set = new Map([
            ["aaa", 111],["bbb", 222],["ccc", 333],
        ])
        ```

- 使用 `for of` 循环遍历时，每次循环都会返回一个包含key和value的数组

- 常用方法

    |方法|说明|
    |-|-|
    |size|getter属性，获取kv对的个数|
    |set(key, value)|添加kv对|
    |get(key)|使用key获取value|
    |delete(key)|删除某个kv对|
    |has(key)|检查是否包含某个kv对|
    |clear()|清空map容器|

- 示例
    - 参考代码
        - [src/es6/map/base.html](src/es6/map/base.html)

    - 代码内容
        ```js
        // 1. 空map
        let map01 = new Map()
        console.log(map01)
        // 输出: Map(0) {}

        // 2. 使用二维数组初始化map容器
        let map02 = new Map([
            ["aaa", 111],["bbb", 222],["ccc", 333],
        ])
        console.log(map02)
        // 输出: Map(3) {"aaa" => 111, "bbb" => 222, "ccc" => 333}

        map02.set("ddd",444)
        console.log(map02)
        // 输出: Map(4) {"aaa" => 111, "bbb" => 222, "ccc" => 333, "ddd" => 444}

        console.log(map02.get("bbb"))
        // 输出: 222
        console.log(map02.get("sss"))
        // 输出: undefined

        map02.delete("aaa")
        console.log(map02)
        // 输出: Map(3) {"bbb" => 222, "ccc" => 333, "ddd" => 444}

        // 遍历map
        for(let n of map02){
            console.log(n)
        }
        // 输出: (2) ["bbb", 222]
        // 输出: (2) ["ccc", 333]
        // 输出: (2) ["ddd", 444]

        map02.clear()
        console.log(map02)
        // 输出: Map(0) {}
        ```

## for_of循环
[top](#catalog)
- 只有支持Iterator的数据类型才能使用 `for of` 循环
- 自定义对象添加 `[Symbol.iterator]` 属性之后，可以使用 `for of` 循环
- 内置的已支持Iterator的数据类型
    1. String
        - 遍历每个字符
        - 与 for in不同，for in是遍历index
    2. Array
        - 遍历每个元素的值
        - 与 for in不同，for in是遍历index
    3. arguments
    4. set容器
        - 返回每个值
    5. map容器
        - 返回kv组成的数组

# es7
## async函数
### async函数的概念与基本使用
[top](#catalog)
- 什么是async函数?
    - 真正意义上解决异步回调的问题
    - 以同步的方式解决异步的问题

- async函数的本质
    - Generator函数的语法糖

- 语法
    ```js
    async function foo(){
        await 异步操作
        await 异步操作
    }
    ```

- async函数的特点
    - 本质是Generator，但是不需要通过 `next()` 方法来调用
    - 遇到 `await` 时开始等待异步操作完成。异步操作完成后继续执行后续代码
    - async 函数返回的**总是** `Promise`对象，可以用 `then()` 方法执行下一步操作
        - 即使代码中的返回值不是Promise对象，引擎也会自动封装
    - 对 Generator函数声明的部分替代
        - 使用 `async` 替代 `function*` 的 `*`
        - 使用 `await` 替代 `yield`

- await 的特点
    - **只能使用在 async 函数中，不能单独使用**
    - 是阻塞的，可以将异步方法编程同步
- await 的返回值
    - 如果函数是普通函数: 函数的返回值，就是 await的返回值
    - 如果是 Promise 对象: 调用 `resolve()`、`reject()` 时传递的参数就是 await的参数; 如果没有传参，await 是 undefined

- await 后的异步操作是 Promise对象时的异常处理
    - 如果直接在 Promise 中调用 `reject()` 方法时，async函数会报错
    - 异常的解决方法
        1. 在 Promise 中，可以用 `resolve()` 替换 `reject()`
        2. 通过 `resolve()` 传递数据时，传递一个异常标识
        3. 在 async 函数中通过异常标识来判断异步操作是否成功

- 示例
    - 参考代码
        - [src/es7/async/base.html](src/es7/async/base.html)

    - 代码内容
        ```js
        // 1. 基本使用方法
        function foo(){
            return new Promise((resolve, reject)=>{
                setTimeout(resolve, 2000);
            })
        }

        async function bar(){
            console.log(new Date().toTimeString())
            await foo()
            console.log(new Date().toTimeString())
        }
        bar()

        // 2. 在 async 中获取 await 的返回值
        async function awaitPrint(){
            console.log("awaitPrint running")

            // await 后面是一个普通函数
            let result01 = await (()=> "testStr")()
            console.log("result01 =", result01)
            // result01 = testStr

            // await 后面是一个 Promise对象
            let result02 = await Promise.resolve();
            console.log("result02 =", result02)
            // result02 = undefined

            let result03 = await Promise.resolve("success");
            console.log("result03 =", result03)
            // result03 = success

            // 报错
            // let result04 = await Promise.reject("failure");
            // console.log("result04 =", result04)
            // Uncaught (in promise) failure
        }

        let x = awaitPrint()
        console.log(x)
        // Promise {<pending>}
        ```

### async函数的执行顺序
[top](#catalog)
- async的代码分类
    - async函数本身是 初始化代码
    - await 部分是 回调函数代码

- 执行顺序
    1. 执行初始化代码时，所有代码按照调用顺序执行，包括 async函数
    2. 执行 async 函数时，按照初始化代码开始执行
    3. 遇到 await 时，执行 await函数
    4. 执行 await函数中的异步任务时，将任务发送到 事件管理模块，然后<span style="color:red">跳出当前await函数和async函数</span>，继续执行后续的初始化代码
    5. 当初始化代码执行结束，事件循环开始执行 await 中的异步任务
    6. await 中的异步任务执行完成之后，执行 async函数内部 的剩余代码

- 执行流程
    1. 初始化代码执行部分
        ```
         初始化代码
            │
            V
         async代码
            │
            V
          await 函数中的同步代码
            │
            V
          await 函数中的异步代码 ───> 事件管理模块
            │
            V
          记录 await 的调用点为A
            |
            V
          跳出 async
            │
            V
         后面的初始化代码
            │
            V
         初始化代码 执行完毕
            │
            V
        执行栈清空
        ```

    2. 开始事件轮询
        ```
        事件管理模块
            │
            V
        await中的异步事件触发，回调函数进入回调队列
            │
            V
        事件轮询搜索队列
            │
            V
        取出函数放入执行栈
            │
            V
         await的异步函数执行完毕，回到离开时的调用点 A
            │
            V
         执行 async 中剩余的代码
        ```

- 执行顺序测试
    - 参考代码
        - [src/es7/async/sequence_of_async.html](src/es7/async/sequence_of_async.html)
    - 代码内容
        ```js
        // async函数执行顺序测试
        function foo(){
            return new Promise((resolve, reject)=>{
                setTimeout(()=>{
                    console.log("time=3000ms, now=" + new Date().toTimeString())
                }, 3000);
                console.log("foo Promise step1")
                setTimeout(()=>{
                    console.log("time=2000ms, now=" + new Date().toTimeString())
                    resolve()
                }, 2000);
                console.log("foo Promise step2")
            }).then(()=>{console.log("foo then")})
        }
        
        function foo2(){
            return new Promise((resolve, reject)=>{
                console.log("foo2 Promise step1")
                setTimeout(()=>{
                    console.log("time2=2000ms, now=" + new Date().toTimeString())
                    resolve()
                }, 2000);
            }).then(()=>{console.log("foo2 then")})
        }


        async function bar(){
            console.log(new Date().toTimeString())
            await foo()
            console.log("async step2")
            await foo2()
            console.log("async end")
        }
        
        let x = bar() // 执行异步函数
        console.log(x)

        // 证明: 消息队列不会在回到调用点之前执行
        setTimeout(()=>{console.log("outter timer = 1000ms")}, 1000)
        setTimeout(()=>{console.log("outter timer = 2000ms")}, 2000)

        // 执行一个非常耗时的操作
        for(let i=0; i<1000000000; i++){}
        console.log("for end")

        // 输出顺序：
        // 17:26:51 GMT+0800
        // foo Promise step1
        // foo Promise step2
        // Promise {<pending>}
        // for end
        // outter timer = 1000ms
        // time=2000ms, now=17:26:53 GMT+0800
        // foo then
        // async step2
        // foo2 Promise step1
        // outter timer = 2000ms
        // time=3000ms, now=17:26:54 GMT+0800
        // time2=2000ms, now=17:26:55 GMT+0800
        // foo2 then
        // async end
        ```

## 指数幂运算符
[top](#catalog)
- 指数幂运算符： `**`

## ES7-Array扩展
[top](#catalog)
- `Array.prototype.includes(value)`，判断数组中是否包含指定值
- 判断方式
    - 基本数据类型，判读数值
    - 对象类型，判断地址
- 示例
    ```js
    let a = {name:"test"}
    let arr = [1,2,3, "dgdf", 44, a]
    // 判读对象是否存在，实际是判断对象的地址
    console.log(arr.includes(a)) // true
    console.log(arr.includes({name:"test"})) // false

    // 判断基本数据类型
    console.log(arr.includes(2)) // true
    ```

[top](#catalog)
