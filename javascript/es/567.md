<span id="catalog"></span>

### 目录
- [ECMASricpt基本知识](#ECMASricpt基本知识)
- [ES5](#ES5)
    - [严格模式](#严格模式)
    - [json扩展]](#json扩展)
    - [Object对象扩展](#Object对象扩展)
        - [常用扩展方法](#常用扩展方法)
        - [扩展方法的使用方式](#扩展方法的使用方式)
    - [Array对象的扩展](#Array对象的扩展)
    - [Function对象的扩展](#Function对象的扩展)
- [ES6](#ES6)
    - [let关键字](#let关键字)
    - [const关键字](#const关键字)
    - [变量的解构赋值](#变量的解构赋值)
    - [模板字符串](#模板字符串)
    - [对象的简写方式](#对象的简写方式)
    - [箭头函数](#箭头函数)
    - [三点运算符](#三点运算符)
    - [形参默认值](#形参默认值)
    - [Promise对象](#Promise对象)
    - [Symbol属性](#Symbol属性)
- [](#)
- [](#)
- [](#)
- [](#)
- [](#)


# ECMASricpt基本知识
[top](#catalog)
- ECMASricpt是有ECMA组织指定和发布的脚本语言规范
- 常用的JS是ECMASricpt的一种实现，但一般JS和ECMASricpt的含义相同
- 创建的ES扩展
    - 浏览器端的JS
    - NodeJS
- ES的几个重要版本
    - ES5：09年发布
    - ES6（ES2015）：15年发布
    - ES7（ES2016）：16年发布

# ES5
## 严格模式
[top](#catalog)
- 一般的代码中使用的都是普通模式，也成为混杂模式
- ES5中添加了第二种运行模式：严格模式，`strict mode`
- 严格模式的作用
    - 消除JS语法中的不严谨、不合理的地方，减少意外行为
    - 提升代码的安全性
    - 为未来的JS版本做铺垫
- 使用方法
    - 全局或函数的第一条语句为：`'use strict';`
    - 如果浏览器版本不支持，则会被解析为一条简单的语句，没有任何副作用
- 使用严格模式后，**语法和行为的改变**
    1. 必须使用 `var` 声明变量
    2. 禁止自定义函数中的 `this` 指向 `window`
    3. 创建eval作用域
    4. 对象不能有重名属性

- 语法和行为的改变说明
    1. 禁止自定义函数中的 `this` 指向 `window`
        - 即防止 `构造函数(...)` 这样的直接调用
        - 这种直接调用会将 window对象 绑定到 this
        - 防止在构造函数内部需改 window对象 中的重要属性或函数
    2. 创建eval作用域
        - 如果不启动严格模式，eval中的代码在全局作用域中执行
        - 启动严格模式之后，为eval函数单独创建一个局部作用域
            - 代码字符串中的变量、函数等，都会变为局部作用域内的数据
        - 为什么要为eval函数创建单独的局部作用域?
            1. 假设eval中的代码字符串是从服务器返回的
            2. 如果代码字符串中参杂了恶意攻击的代码，这些代码直接操作 window对象，则用户很容易被攻击
    3. 对象不能有重名属性
        - 防止误操作导致的重命名
        - 这一条只是代码检查中会报错，实际执行时不会报错
        - 如果出现的重名属性，则后声明的会覆盖先声明的
- 示例
    - 参考代码
        - [src/es5/strict_mode/base.html](src/es5/strict_mode/base.html)
    - 代码内容
        ```js
        'use strict'
        // 1. 必须使用 `var` 声明变量
        // a = 100  // 异常：ReferenceError: a is not defined
        var a = 100
        console.log(100)

        // 2. 禁止自定义函数中的 `this` 指向 `window`
        function Person(name, age){
            this.name = name
            this.age = age
        }

        var p01 = new Person("aaa", 18)

        // 异常：TypeError: Cannot set property 'name' of undefined
        // Person("bbb", 20)

        // 3. 创建eval作用域
        var str = "outter str"
        eval('var str="inner str"; console.log(str)') // 输出:inner str
        console.log(str)
        // 普通模式，输出：inner str，即修改了全局作用域中的变量
        // 严格模式，输出：outter str

        // 4. 对象不能有重名属性
        var obj = {
            name:"aaaa",
            name:"bbb"
        }
        console.log(obj.name)
        // 不会报错
        // 输出: bbb
        ```

## json扩展
[top](#catalog)
- `var JSON字符串 = JSON.stringify(JS对象)`
    - 将js对象转换为JSON字符串
- `var JS对象 = JSON.parse(JSON字符串)`
    - 将JSON字符串转换为js对象
- JSON只有两种类型
    - JSON数组
    - JSON对象

## Object对象扩展
### 常用扩展方法
[top](#catalog)
1. `Object.create(prototype [, descriptors])`，以某个对象为原型创建对象，并扩展属性
2. `Object.defineProperties(object, descriptors)`，为已有对象添加getter、setter
3. 创建对象时，对象自身的 getter、setter 方法

### 扩展方法的使用方式
[top](#catalog)
- `Object.create(prototype [, descriptors])`
    - 用途：
        1. 指定某个对象为原型创建新的对象
        2. 通过 `descriptors` 参数，为新对象扩展属性，并**对属性进行描述**
    - `descriptors` 参数的设置方法
        ```js
        {
            属性名: {
                value: 属性值,
                writable: 当前属性是否可修改（默认为false）,
                configurable: 当前属性是否可以被删除（默认为false）,
                enumerable: 当前属性是否能用 `for in` 进行枚举（默认为false）
            },
            ....
        }
        ```
    - 对于不可修改、不可删除、不可遍历的属性，可以执行对应的操作，不会报错，但是**操作不会生效**
    - 示例
        - 参考代码
            - [src/es5/object/extends.html](src/es5/object/extends.html)
        - 代码内容
            ```js
            // 1. 指定某个对象为原型创建新的对象
            var obj0101 = {name:'aaa', age:14}
            var obj0102 = Object.create(obj0101)
            console.log("obj0102.name =", obj0102.name)
            // 输出: obj0102.name = aaa
            console.log(obj0102)

            // 2. 在原型的基础上，通过 descriptors 参数，为新对象扩展属性
            var obj0201 = {name:'bbb', age:15}
            var obj0202 = Object.create(
                obj0201,
                {
                    gender:{
                        value:false,
                        writable:true,
                        configurable:true,
                        enumerable:true
                    },

                    address:{
                        value:"test address",
                        writable:false,
                        configurable:false,
                        enumerable:false
                    }
                }
            )

            // 2.1 修改可修改属性
            console.log("obj0202.gender =", obj0202.gender)
            // 输出: obj0202.gender = false

            obj0202.gender = true
            console.log("obj0202.gender =", obj0202.gender)
            // 输出: obj0202.gender = true

            // 2.2 修改不可修改属性
            console.log("obj0202.address) =", obj0202.address)
            // 输出: obj0202.address) = test address
            obj0202.address = "new address"
            console.log("obj0202.address) =", obj0202.address)
            // 输出: obj0202.address) = test address

            // 2.3 遍历所有属性
            for(var p in obj0202){
                console.log("p =", p)
            }

            // 遍历输出:
            // p = gender
            // p = name
            // p = age

            // 2.4 删除属性
            delete obj0202.gender //可删除
            delete obj0202.address //不可删除
            console.log("obj0202 =", obj0202)
            // 输出: obj0202 = {address: "test address"}
            ```

- `Object.defineProperties(object, descriptors)`
    - 用途:
        - 为已有的对象扩展属性
        - 用于替换:`obj.新属性 = 新属性值` 这种直接在对象上添加属性的方式
    - `descriptors` 参数的设置新属性的 getter、setter
        ```js
        {
            属性名:{
                get: function(){
                    // 获取扩展属性
                    // 内部可以使用 this 对象
                },
                set: function(data){
                    // 修改扩展属性
                    // 内部可以使用 this 对象
                    // 监听属性，当属性发生修改时，自动执行
                }
            }
        }
        ```
    - 示例
        - 参考代码
            - [src/es5/object/extends.html](src/es5/object/extends.html)

        - 代码内容
            ```js
            // 3. 为指定对象定义扩展多个属性
            var obj03 = {firstName:"aaa", lastName:"ccc"}
            Object.defineProperties(
                obj03,
                {
                    fullName:{
                        get: function(){
                            return this.firstName + " " + this.lastName
                        },
                        set: function(data){
                            var result = data.split(" ");
                            this.firstName = result[0]
                            this.lastName = result[1]
                        }
                    }
                }
            )

            console.log("obj03.fullName =", obj03.fullName)
            // 输出: obj03.fullName = aaa ccc
            obj03.fullName = "xxx yyy"
            console.log("obj03.fullName =", obj03.fullName)
            // 输出: obj03.fullName = xxx yyy
            ```

- 对象自身的 getter、setter 方法
    - 只能在创建对象时使用
    - 与 `Object.defineProperties(object, descriptors)` 的功能一致
        - 对象内部的结构也基本相同
    - 设置方法
        ```js
        var 对象 = {
            get 属性名(){
                // 获取属性值
                // 可以使用this对象
            }
            set 属性名(data){
                // 设置属性值
                // 可以使用this对象
            }
        }
        ```
    - 示例
        - 参考代码
            - [src/es5/object/extends.html](src/es5/object/extends.html)

        - 代码内容
            ```js
            // 4. 设置对象自身的getter和setter
            var obj04 = {
                firstName:"object",
                lastName:'04',
                get fullName(){
                    return this.firstName + " " + this.lastName
                },
                set fullName(data){
                    var result = data.split(" ")
                    this.firstName = result[0]
                    this.lastName = result[1]
                }
            }

            console.log("obj04.fullName =", obj04.fullName)
            // 输出: obj04.fullName = object 04
            obj04.fullName = "new name"
            console.log("obj04.fullName =", obj04.fullName)
            // 输出: obj04.fullName = new name
            ```

- 两种getter、setter设置方法的对比
    - 参考代码
        - [src/es5/object/extends.html](src/es5/object/extends.html)

    - 对比结果
        ```js
        // 5. 检查两种添加 getter、setter 方式的对象结构
        console.log(obj03)
        console.log(obj04)

        // obj03:   defineProperties
        // {firstName: "xxx", lastName: "yyy"}
        // firstName: "xxx"
        // lastName: "yyy"
        // fullName: (...)
        // get fullName: ƒ ()        <----getter函数名不同
        // set fullName: ƒ (data)    <----setter函数名不同
        // __proto__: Object

        // obj04:   getter、setter
        // {firstName: "new", lastName: "name"}
        // firstName: "new"
        // fullName: (...)
        // lastName: "name"
        // get fullName: ƒ fullName()      <----getter函数名不同
        // set fullName: ƒ fullName(data)  <----setter函数名不同
        // __proto__: Object
        ```

## Array对象的扩展
[top](#catalog)
- Array 的显示原型对象上的扩展方法

    |扩展方法|描述|
    |-|-|
    |`Array.prototype.indexOf(value)`|获取 value 在数组中第一次出现的下标|
    |`Array.prototype.lastIndexOf(value)`|获取 value 在数组中最后一次出现的下标|
    |`Array.prototype.forEach(function(item, index){})`|遍历数组，并应用函数|
    |`Array.prototype.map(function(item, index){})`|<ul><li>遍历数组并返回一个新数组</li><li>对数组的每个元素应用变化函数</li><li>函数的返回值作为一个新数组的元素</li></ul>|
    |`Array.prototype.filter(function(item, index){})`|<ul><li>遍历数组并返回一个新数组</li><li>根据函数来过滤元素</li><li>函数的返回值`true`时，将当前遍历的元素添加到新数组中；返回`false`时，跳过当前元素</li></ul>|

- 数组的扩展内容都绑定在 Array函数对象的显示原型上，所以数组对象可以直接使用 （通过隐式原型）

- 这些扩展方法只是用于 Array 的实例对象与子类对象。但是**对于类数组对象不可用**

- 示例
    - 参考代码
        - [src/es5/array/extends.html](src/es5/array/extends.html)
    - 代码内容
        1. 输出第一个6的下标
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result01 = arr.indexOf(6)
            console.log("result01 =", result01)
            // 输出: result01 = 4
            ```
        2. 输出最后一个6的下标
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result02 = arr.lastIndexOf(6)
            console.log("result02 =", result02)
            // 输出: result02 = 8
            ```
        3. 输出所有元素的值和下标
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            arr.forEach(function(item, index){
                console.log("result03: index = " + index + ", arr[" + index + "] = " + arr[index])
            })
            ```
        4. 根据原始数组产生一个新数组，将数组的所有元素加10
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result04 = arr.map(function(item){
                return item + 10
            })
            console.log("result04 =", result04)
            // 输出: result04 = (10) [12, 13, 14, 15, 16, 17, 18, 19, 16, 10]
            ```

        5. 根据原始数组产生一个新数组，返回大于4的元素
            ```js
            var arr = [2,3,4,5,6,7,8,9,6,0]

            var result05 = arr.filter(function(item){
                return item > 4
            })
            console.log("result05 =", result05)
            // 输出: result05 = (6) [5, 6, 7, 8, 9, 6]
            ```

## Function对象的扩展
[top](#catalog)
- `Function.prototype.bind(obj [, param1, param2])`
    - 用途：
        - 将函数内的this绑定为obj，并**返回一个新的函数对象**
        - 如果bind中还有其他参数，则按照顺序绑定到函数的参数中
    - 使用场景
        - 修改回调函数中的this对象
- bind 与 call、apply 的区别
    - call、apply 会立即执行
    - bind 会将函数返回，并延迟执行

- 示例
    - 参考代码
        - [src/es5/function/extends.html](src/es5/function/extends.html)
    - 代码内容
        1. 只绑定函数的this
            ```js
            // 1.1 原始函数
            function foo(data){
                console.log(this)
                console.log(data)
            }

            // 1.2 创建对象-->绑定this-->执行新的函数
            var obj = {name:"obj"}
            var bar = foo.bind(obj)
            bar(1234)
            // 输出:
            // {name: "obj"}
            // 1234

            // 1.2. 执行原始函数
            foo(5678)
            // 输出:
            // Window {parent: Window, …}
            // 5678
            ```
        2. 绑定 this 和函数的其他参数
            ```js
            function foo02(a, b){
                console.log(this)
                console.log("a =", a)
                console.log("b =", b)
            }

            var obj02 = {name:"obj02"}
            var bar02 = foo02.bind(obj02, 10)
            bar02(20)
            // 输出:
            // {name: "obj02"}
            // a = 10
            // b = 20

            ```

        3. 修改回调函数中的this
            ```js
            var obj03 = {name:"obj03"}
            setTimeout(
                (function(){console.log(this)}).bind(obj03),
                300
            )
            // 输出: {name: "obj03"}
            ```

# ES6
## let关键字
[top](#catalog)
- `let` 关键字
    - 作用：与 var 类似，用于声明变量
    - 特性
        - 使变量只在块级作用域内有效
        - 在作用域内，不能重复声明同名变量
        - 使变量在创建执行上下文时，不参与预处理，不被提升
    - 场景的应用场景
        - 循环遍历加监听
- 示例
    - 参考代码
        - [src/es6/let/base.html](src/es6/let/base.html)
    - 代码内容
        1. 在作用域内，不能重复声明同名变量
            ```js
            let a = 100
            // SyntaxError: Identifier 'a' has already been declared
            // let a = 200
            console.log(a)
            ```
        2. 使变量在创建执行上下文时，不参与预处理，不被提升
            ```js
            // 在变量声明之前，访问使用let声明的变量
            // ReferenceError: Cannot access 'b' before initialization
            // console.log(b)
            let b = 300
            ```
        3. 循环遍历加监听--- let 使变量只在块级作用域内有效
            ```js
            // 为每个按钮绑定点击事件。点击时输出自身的index
            var buttons = document.getElementsByTagName("button")
            var buttons_length = buttons.length
            for(let i=0; i<buttons_length; i++){
                // 每一次循环都会创建let对应的作用域，事件处理函数中只会使用当前作用域中的值
                buttons[i].onclick = function(){
                    console.log("i =", i)
                }
            }
            ```

## const关键字
[top](#catalog)
- const关键字
    - 作用: 定义一个常量
    - 特点
        - 常量不可以修改该
        - 与let类似
            - 使变量只在块级作用域内有效
            - 在作用域内，不能重复声明同名变量
            - 使变量在创建执行上下文时，不参与预处理，不被提升

## 变量的解构赋值
[top](#catalog)
- 什么是解构赋值?
    - 从对象或数组中提取数据，并赋值给（多个）变量
- 对象的解构
    - 语法
        - 需要用 `{}` 将多个变量括起来，如 `{param1, parm2,...} = 对象`
        - 与属性名相同的变量名会被赋值
        - 变量的顺序没有要求
        - 如果某个变量名在对象中**没有对应的属性名**，则只会声明，不会被赋值，即为 `undefined`
    - 完全匹配
        - `let {name, age} = {name:"aaa_name", age:20}`
    - 部分匹配
        - `let {price, address} = {price:60, address:"qqq", school:"xxxx"}`
    - 只匹配一个
        - `let {one} = {one: "oneStr", two:"twoStr"}`
    - 变量过多，无法匹配的自动忽略
        - `let {first, second, third} = {first:"firstStr", second:"secondtr"}`

- 数组的解构
    - 语法
        - 需要用 `[]` 将多个变量括起来，如 `[aram1, parm2,...] = 数组`
        - 按下标顺序为每个变量赋值
            - 如果变量多了，则只定义，不赋值，即 `undefined`
            - 如果变量少了，只从数组中抽取对应数量的元素进行赋值
            - 不需要赋值的index，使用`,`来跳过
    - 完全匹配
        - `let [a, b] = [1, 2]`
    - 部分匹配
        - `let [c, d] = [5, 6, 7, 8, 9]`
    - 变量过多，无法匹配不赋值
        - `let [e, f, g] = [10, 11]`
    - 跳过某个元素
        - `let [h, , j] = [12, 13, 14]`

- 解构赋值的应用
    - 函数的参数使用解构的形式: `function 函数名({参数1, 参数2})`
    - 传递实参时直接传递对象，减少通过对象获取属性的代码
    - 如果函数使用了解构形式的参数，则**无法再通过一一传递参数的方式调用函数**
        - 如果仍然使用传统方式，则参数的值都是 `undefined`

    - 使用方法
        ```js
        // 使用解构的格式作为形参
        function foo({name, age}){
            
        }
        // 调用时，直接将对象作为实参传递，不需要通过 对象.属性名的方式，一一传递
        var obj = {...}
        foo(obj)
        ```
- 示例
    - 参考代码
        - [src/es6/deconstruct/base.html](src/es6/deconstruct/base.html)
    - 代码内容
        1. 对象的解构
            ```js
            // 1.1 完全匹配
            let {gender, name, age} = {name:"aaa_name", age:20, gender:true}
            console.log("name =", name)         // name = aaa_name
            console.log("age =", age)           // age = 20
            console.log("gender =", gender)     // gender = true

            // 1.2 部分匹配
            let {price, address} = {price:60, address:"qqqwwweee", school:"xxxx"}
            console.log("price =", price)       // price = 60
            console.log("address =", address)   // address = qqqwwweee

            // 1.3 只匹配一个
            let {one} = {one: "oneStr", two:"twoStr"}
            console.log("one =", one)           // one = oneStr

            // 1.4 匹配对象中不存在的匹配项
            let {first, second, third} = {first:"firstStr", second:"secondtr"}
            console.log("first =", first)       // first = firstStr
            console.log("second =", second)     // second = secondtr
            console.log("third =", third)       // third = undefined
            ```

        2. 数组的解构
            ```js
            // 2.1 完全匹配
            let [a, b] = [1, 2]
            console.log("a =", a)
            console.log("b =", b)

            // 2.2 部分匹配
            let [c, d] = [5, 6, 7, 8, 9]
            console.log("c =", c)
            console.log("d =", d)

            // 2.3 变量过多，无法匹配 g，则不赋值
            let [e, f, g] = [10, 11]
            console.log("e =", e)
            console.log("f =", f)
            console.log("g =", g)

            // 2.4 跳过某个元素
            let [h, , j] = [12, 13, 14]
            console.log("h =", h)       // j = 14
            console.log("j =", j)       // h = 12
            ```

        3. 解构赋值的应用
            ```js
            // 使用解构的格式作为形参
            function show({name, age}){
                console.log("name =", name)
                console.log("age =", age)
            }

            var obj = {name: "objName", age:30}
            show(obj)       // 不需要依次调用对象的属性，直接将对象作为实参传递
            // 输出:
            // name = objName
            // age = 30
            ```

## 模板字符串
[top](#catalog)
- 模板字符串的作用
    - 简化字符串的拼接

- 语法
    - 使用反引号将字符串括起来
    - 需要使用变量的部分，通过 `${变量}` 的方式来引用
    - 需要使用函数调用结果的部分，通过 `${函数()}` 的方式来引用
        ```
        `xxxxxx${变量}xxxx`
        `xxxxxx${fn()}xxxx`
        ```
    - 模板字符串中的空格和换行都会被保留

- 示例
    - 参考代码
        - [src/es6/string/template.html](src/es6/string/template.html)
    - 代码内容
        ```js
        // 1. 输出变量
        let obj = {
            name:"testName",
            age:20,
            gender:false
        }

        console.log(`name=${obj.name}, age=${obj.age}, gender=${obj.gender}`)
        // 输出：
        // name=testName, age=20, gender=false

        // 2. 输出函数调用结果
        let foo = ()=> "abcd"
        console.log(`result = ${foo()}`)
        // 输出:

        // 3. 模板字符串保留空格和换行
        let str = `
            1111
            2222
            3333`
        console.log(str)
        ```

## 对象的简写方式
[top](#catalog)
- 省略的内容
    1. **与变量同名的属性**可以省略，直接写变量名即可
    2. 方法的 `function` 关键字可以省略
- 示例
    - 参考代码
        - [src/es6/object/simple.html](src/es6/object/simple.html)
    - 代码内容
        ```js
        let name = "myname"
        let age = 25
        let obj = {
            name,
            age,
            show(){ // 省略原始的写法  show: function(){...}
                console.log(`name = ${this.name}, age = ${this.age}`)
            }
        }

        obj.show() // name = myname, age = 25
        ```

## 箭头函数
[top](#catalog)
- 用途：**定义匿名函数**
    - 虽然是匿名函数，但是可以用**函数表达式**的形式将函数赋值给变量，来复用
- 语法
    - 不同数量参数的函数声明方式
        - 无参函数：`() => 语句/表达式/{代码块}`
        - 一参函数：
            - `p => 语句/表达式/{代码块}`，推荐使用
            - `(p) => 语句/表达式/{代码块}`
        - 多数函数： `(a, b) => 语句/表达式/{代码块}`

    - 语句、表达式、代码块的写法
        - 如果函数体只有一行或表达式时，则不需要使用 `{}` 包裹，并且**表达式的结果作为函数返回值**
        - 如果函数体有多行，则必须按照正常的函数写法来编写，如果有返回值需要手动返回

- 箭头函数的特点
    1. 声明简洁
    2. <label style="color:red">箭头函数没有自己的 `this`</label>
        - 箭头函数的 this 不是在函数调用时决定的，而是在**定义时**决定的
        - 箭头函数定义在哪个对象中，this 就是那个对象
        - 如果在全局作用域声明箭头函数，则 this 是 window 对象

- 箭头函数中 this 对象的区分方法
    - 如果 箭头函数外层还有函数，则 this 是外层的函数所属的 this
        - 如果外层函数也是箭头函数，则继续向外层查找，直到 window对象
    - 如果 箭头函数外层没有函数，则 this 是 window

- 箭头函数的应用
    - 多用于回调函数

- 示例
    - 参考代码
        - [src/es6/function/arrow.html](src/es6/function/arrow.html)
    - 代码内容
        1. 参数的数量
            ```js
            // 1.1 无参函数
            let fn0101 = () => console.log("this is fn0101")
            fn0101()
            // 输出: this is fn0101

            // 1.2 一个参数
            let fn0102 = a => console.log(`a = ${a}`)
            fn0102("testStr")
            // 输出: a = testStr

            // 1.3 多个参数
            let fn0103 = (a, b) => a + b
            let result0103 = fn0103(3,6)
            console.log(`result0103 = ${result0103}`)
            // 输出: result0103 = 9
            ```
        2. 箭头函数的this
            ```js
            // 2.1 在全局作用域中定义箭头函数
            let fn0201 = () => console.log(this)
            fn0201()
            // 输出: Window {parent: Window, …}

            // 2.2 在全局作用域的函数内部定义箭头函数
            function fn0202(){
                // 外层函数属于 window，所以箭头函数的this仍然是 window
                let f = ()=>console.log(this)
                f()
            }
            fn0202()
            // 输出: Window {parent: Window, …}

            // 2.3 在对象函数的内部定义箭头函数
            let obj = {
                name:'objName',
                age:23,
                show(){
                    let f = () => console.log(this)
                    f()
                }
            }
            obj.show()
            // 输出: {name: "objName", age: 23, show: ƒ}

            // 2.4 箭头函数的外层函数还是箭头函数
            let obj0201 = {
                name:'obj2Name',
                age:26,
                show: ()=>{ // 外层函数仍然是箭头函数
                    let f = () => console.log(this)
                    f()
                }
            }
            obj0201.show()
            // 输出: Window {parent: Window, …}
            ```

## 三点运算符
[top](#catalog)
- 用途：
    1. rest可变参数
        - 用来取代 arguments对象，但是比 arguments 更加灵活
            - argument是类数组对象，rest是数组数组对象，可以使用 Array 上的方法
        - 可变参数**只能放在**函数**参数的最后**
    2. 扩展运算
        - 在数组使用通过三点运算符，可自动遍历其他数组，并将元素添加到新数组中
            ```js
            let a = [1,2,3]
            let b = [1, ...a, 6]
            ```
- 示例
    - 参考代码
        - [src/es6/function/rest_param.html](src/es6/function/rest_param.html)

    - 代码内容
        1. rest可变参数
            ```js
            function foo(a, ...values){
                console.log(a)
                console.log(values)
                values.forEach(item => console.log(item))
            }

            foo(1,2,3,4,5, "abc")
            // 输出:
            // 1
            // (5) [2, 3, 4, 5, "abc"]
            // 2
            // 3
            // 4
            // 5
            // abc
            ```
        2. 扩展运算
            ```js
            let a = [1, 2, 3]
            let b = [1, ...a, 6]
            console.log(b)
            // 输出:
            // (5) [1, 1, 2, 3, 6]
            ```

## 形参默认值
[top](#catalog)
- 在声明函数时，为参数赋值。创建实例对象时，如果没有传参，则使用默认值
    ```js
    function Point(x=0, y=0){
        this.x = x
        this.y = y
    }
    ```

## Promise对象
[top](#catalog)
- 什么是 Promise 对象?
    - Promise 对象代表了未来某个将要发生的事件，通常是一个异步操作
    - 有了 Promise 对象，可以用同步的编码方式来处理异步操作，避免多层回调函数
    - ES6 中的 Promise 对象是一个构造函数，用来生成 Promise实例

- Promise对象的三种状态
    1. pending，初始化状态
    2. fullfilled，成功状态
    3. rejected，失败状态

- 使用方法
    - 创建Promise对象
        - `new Promise((resolve, reject)=>{...})`
        - 在函数中进行初始化，将状态修改为 `pending`
        - **函数的执行是同步的，不是作为回调函数使用**
        - 在函数内部调用异步操作，并通过 resolve、reject 来修改 Promise对象的状态
        - 如果没有调用 resolve、reject，则 Promise对象的状态将一直是 `pending`
    - `resolve(data)`
        - 异步任务成功 时执行
        - 修改promise的状态为`fullfilled`
        - 通过data参数向外部传值
    - `reject(data)`
        - 异步任务失败 时执行
        - 修改promise的状态为`rejected`
        - 通过data参数向外部传值
    - 异步调用的响应:
        - 响应方式
            ```js
            promise对象.then(
                fullfilled状态--响应函数,
                rejected状态--响应函数,
            )
            ```
        - 如果没有在实例化方法的函数中调用 resolve 或 reject，Promise对象的状态将一直是 `pending`，并且**不会调用** `then` 中的任何方法
        - 两种状态的响应函数都可以通过第一个参数来获取通过 resolve、reject 传输的参数
            ```js
            promise.then(
                data=>{...},
                data=>{...}
            )
            ```
        - `then`可以链式调用，前提是前一个then中的响应函数返回了一个promise对象

- 示例
    - 参考代码
        - [src/es6/promise/base.html](src/es6/promise/base.html)
    - 代码内容
        ```js
        let promise = new Promise((resolve, reject)=>{
            // 初始化promise， 状态：pending
            console.log("promise init start")

            // 执行异步操作，通常是发送ajax请求、开启定时器
            setTimeout(()=>{
                console.log("promise inner timer")
                let data = "timer data"
                // 根据异步任务的返回结果去修改promise的状态
                // 异步任务成功
                resolve(data) //修改promise的状态为fullfilled
                // 异步任务失败
                // reject(data) //修改promise的状态为rejected
            }, 2000)
        })

        console.log("promise init end")

        promise.then(
            data=>console.log("success " + data),  // 成功的回调
            error=>console.log("failure " + error)   // 失败的回调
        )

        console.log("promise end")

        // 输出:
        // promise init start
        // promise init end
        // promise end
        // promise inner timer
        // success timer data
        ```

## Symbol属性
[top](#catalog)
- ES5中对象的属性名都是字符串，容易造成充满，污染环境
- 什么是Symbol？
    - ES6中添加的一种原始数据类型
    - 与其他数据类型：String、Number、Boolean、Null、Undefined、Object 的地位相同
- Symbol的特点
    - Symbol属性值是唯一的，可以解决命名冲突的问题
    - Symbol值不能与其他数据进行运算，包括进行字符串拼接
    - `for in`, `for of` 遍历时不会遍历symbol属性

- 内置Symbol值
    - ES6提供了11个内置的Symbol值，执行语言内部使用的方法

- 示例
    - 参考代码
        - [src/es6/symbol/base.html](src/es6/symbol/base.html)
    - 代码内容
        ```js
        // 1. 创建Symbol属性
        let symbol = Symbol();
        console.log(symbol)
        // 输出: Symbol()

        // 2. Symbol值做对象属性
        let obj = {name:"testName", age:22}
        obj[symbol] = "hello"
        console.log(obj)
        // 输出: {name: "testName", age: 22, Symbol(): "hello"}

        for(let p in obj){
            console.log(p)
        }
        // 输出:
        // name
        // age

        // 3. Symbol值的比较
        let a = Symbol()
        let b = Symbol()
        console.log(a === b)
        // 输出: false
        console.log(a, b)
        // 输出: Symbol() Symbol()

        // 4. 创建Symbol时，注入标识
        let c = Symbol("12")
        let d = Symbol("23")
        console.log(c === d)
        // false
        console.log(c, d)
        // 输出: Symbol(12) Symbol(23)

        // 5. 定义Symbol常量
        const key = Symbol("key")
        console.log(key)
        // 输出: Symbol(key)
        ```

## Iterator接口
### Iterator接口的原理与基本使用方法
[top](#catalog)
- Iterator的作用
    1. 为各种数据结构提供一个统一的、简便的访问接口
    2. 使数据结构的成员能按某种次序排列
- 使用场景
    - ES6中的新遍历方式 `for of`，Iterator接口主要供 `for of` 遍历使用
    - 三点运算符，底层使用Iterator接口遍历
    - 解构赋值，底层使用Iterator接口遍历
- 工作原理
    1. 创建一个指针对象（遍历器对象），指向数据结构的起始位置
    2. 调用 `next` 方法，指针自动指向数据结构的第一个元素
    3. 继续调用 `next` 方法，直到最后一个元素
- `next`方法的返回结果
    - 调用 `next` 方法后，返回一个对象：`{value: 当前成员的值, done:布尔值}`
    - value，表示当前元素的值
    - done，表示当前对象是否遍历结束
    - 遍历结束时，返回：`{value:undefined, done:false}`

- 将Iterator接口部署到指定的数据类型上，就可以使用 `for of` 遍历
    - 内置的已部署Iterator的数据类型
        1. String
        2. Array
        3. arguments
        4. set容器
        5. map容器

- 示例
    - 参考代码
        - [src/es6/iterator/base.html](src/es6/iterator/base.html)
    - 遍历内置的已部署Iterator的数据类型
        ```js
        // 1.1 String
        let str = "asdfg"
        for(let n of str){
            console.log(n)
        }
        // 输出：
        // a
        // s
        // d
        // f
        // g

        // 1.2. Array
        let arr = ["aaa", "bbb", "ccc", "ddd"]
        for(let n of arr){
            console.log(n)
        }
        // 输出：
        // aaa
        // bbb
        // ccc
        // ddd

        // 1.3. arguments
        function foo(){
            for(let n of arguments){
                console.log(n)
            }
        }
        foo(1, 2, 3, 4, "dd", "ff")
        // 输出：
        // 1
        // 2
        // 3
        // 4
        // dd
        // ff

        // 1.4 无法遍历对象
        let obj = {name:"testName", age:22}
        // TypeError: obj is not iterable
        // for(let n of obj){
        //     console.log(n)
        // }
        ```

### 自定义Iterator实现
[top](#catalog)
- 通过对象的 `Symbol.iterator` 属性，指向该对象的默认遍历器方法

- 使用 `for of` 遍历某一个数据结构的时候，首先去找 `Symbol.iterator`
找到则遍历，没有则报错

[top](#catalog)
