<span id="catalog"></span>
- 参考
    - 《JavaScript语言精髓与编程实战》

### 目录--JS的结构化特性
- [JS是多范型语言](#JS是多范型语言)
- [JS的基本组织元素](#JS的基本组织元素)
    - [语法元素及其组织含义](#语法元素及其组织含义)
    - [Tokens的概念](#Tokens的概念)
    - [标识符](#标识符)
    - [表达式](#表达式)
    - [语句](#语句)
    - [模块](#模块)
    - [组织的原则](#组织的原则)
- [](#)

# JS是多范型语言
[top](#catalog)
- JS是有交叉分类特性的语言，通常被称为: 多范型语言
    - JS同时是`说明式`和`命令式`的
        - `说明式` 侧重于: 基于算法的实现
        - `命令式` 侧重于: 基于结构的运算
    - JS同时兼具串行、并行语言的特征

# JS的基本组织元素
## 语法元素及其组织含义
[top](#catalog)

|元素|物理形态|静态含义|动态含义|
|-|-|-|-|
|标识符|-|let/const/var<br>函数声明<br>类声明|非严格模式下的var<br>非严格模式下的函数声明|
|表达式|模板字符串?????|值<br>箭头函数体|通过eval执行表达式语句来实现|
|语句|.js文件|块与块级作用域|eval()|
|模块|.mjs文件|import/export<br>require()|import().then()|

## Tokens的概念
[top](#catalog)
- Tokens 是代码静态语法概念
- Tokens 的功能
    1. 将整个代码文本解析成一系列符号
    2. 将代码文本中的程序语义映射成机器逻辑可以处理的对象
        - 如: 抽象语法树 AST

## 标识符
[top](#catalog)
- 在Tokens的层面上，一行语句可以被拆分成:
    1. 标识符
        - 包括 变量名、函数名、类名、模块名等
    2. 标点符号
    3. 字面量
    4. 模板
- 表达的内容

    |元素|表达内容|具体内容|
    |-|-|-|
    |标识符|名字|表示一个名字|
    |字面量|值|表示有字面含义决定的值|
    |模板|值|表示一个可计算的字符串值|

- 既是保留字，也是字面量的标识符
    - null
    - true
    - false
- 标识符 `undefined` <span style='color:red'>既不是保留字，也不是标识符</span>

## 表达式
[top](#catalog)
- 什么是表达式
    - 0～1个运算符、至少 1 个操作数的 **有序书写**
    - 运算符可以是:
        1. 表达符号
        2. 关键字
    - 操作数可以是:
        1. 标识符
        2. 字面量
        3. 模板
- 运算符表达的本质: 引用、值之间的运算，并返回引用、值
    - 因为操作数只能是: 引用、值
- 表达式的形态
    - 0个运算符 + 1个操作数 --- 单值表达式
        ```js
        1
        ```
    - 1个运算符 + 1个操作数
        ```js
        -true; // -1
        -1;    // -1
        ```
    - 1个运算符 + 两个操作数
        ```js
        1 + 1;   // 2
        ```
    - 1个运算符 + 三个操作数
        ```js
        true ? 1 : 2; // 1
        ```
    - 1个运算符 + 未知数量的操作数
        ```js
        function foo(...args){}
        foo(1,2,3,4,5);
        ```
- 表达式的连续计算
    - 运算的顺序由每个独立表达式的运算符优先级决定
    - 普通的连续运算
        ```js
        1 + 2 * 3;
        ```
    - 逗号的 `,` 连续运算，其返回值是最后一个表达式的结果
        - 如果用来赋值，需要和 `()` 一起使用
        - 示例
            ```js
            function foo(...args){}
            var a = (1, 2, 3, 4, 5, foo(1, 2, 3, 4, 5));
            // a = undefined
            ```
- JS表达式的注意事项
    - 表达式不能独立于语句存在
        - 单个表达式，可以被称为 `表达式语句`
        - 单个字面量的操作数，可以被称为 `字面量表达式语句`
    - 表达式结果的用途
        1. 用于持续的表达式计算
            - 如表达式的连续运算
        2. 通过一些语句来展示计算结果
        3. 将计算结果赋值给变量

- 表达式特性与注意事项产生的原因
    - <span style='color:red'>JS的语言引擎被设计为一个按语句行，顺序执行的`行处理器`</span>

- 字面量
    - 对象字面量
        ```js
        {k1: v1, k2: v2}
        ```
    - 数组字面量
        ```js
        [e1, e2, e3]
        ```
    - 正则表达式字面量
        ```js
        /../ig
        ```
- 初始器
    - 初始器只针对: 数组、对象
    - 字面量与初始器的区别
        - 字面量不包括运算过程
        - 初始器可以包括运算过
    - ES5中只明确了5种字面量语法，这些字面量的值是在出现时就可以确定的，包括
        - null
        - true/false
        - 数值
        - 字符串
        - 正则表达式
    - 为什么ES5的字面量不包括 数组 和 对象?
        - 数组、对象出现时，不能完全确定，**必须进行运算**
        - <span style='color:red'>所以所有的数组、对象字面量都是初始器</span>
    - 实际使用的时候，可以**不用严格区分两者**

## 语句
[top](#catalog)
- Tokens的两个演进方式
    1. `函数式语言特性`: 表达式中通过名字来引用值，并进一步地做运算
    2. `命令式语言特性`: 通过语句来串联名字与值，并最终表述为赋值操作

- JS中语句的划分
    - 声明语句
    - 非声明语句

- 声明语句
    - 声明语句都是静态词法分析的
    - 声明的内容
        - 标识符的名字
        - 名字与值的关系，也称为绑定
            - 包括：赋值、函数对象声明
    - 示例
        ```js
        var x; // 声明标识符
        var y = 100; // 赋值
        function foo(){} // 函数声明
        ```
- 非声明语句
    - 非声明语句都是动态执行的

## 模块
[top](#catalog)
- 模块的两个语义
    1. 导出
        - 给外部提供一个可用的导出列表
        - 模块的使用者只能使用导出内容，隐藏了内部的一些实现
    2. 导入
        - 读取模块的导出列表，并使用导出内容

## 组织的原则
[top](#catalog)
- 3 个原则
    1. 控制数据的可变性
    2. 最小逻辑和最大复用
    3. 语法在形式上的清晰与语义一致性

- 原则1: 控制数据的可变性
    - 数据定义行为
        - 数据定义行为可以拆分成4个具体步骤/状态
            1. 命名/声明
            2. 设值前
            3. 设值
            4. 设置后
        - 由数据定义行为产生的变量绑定方式
            - 动态绑定、非动态绑定
            - 每种绑定都存在: 初始化/未初始化，两种状态
    - 可以通过 **减少数据定义的状态数量** 来简化系统
        - 如 `Promise` 的并行特性，本质就是一个**三状态数据**的可编程系统
        - 如 推荐使用 let/const 来替代 var，本质就是减少数据的状态

- 原则2: 最小逻辑和最大复用
    - 最小逻辑的两种趋势
        1. 非结构化
            - 如生成器、Promise
            - 抽离结构化控制结构:顺序、分支、循环，将系统的控制变成了非结构化
        2. 逻辑内聚
            - 创建更大颗粒度的复用单元
            - 对外暴露一致性接口
            - 示例
                - 代码内容
                    ```js
                    Promise.resolve('hello world')
                        .then(console.log);
                    ```
                - Promise的处理
                    - 向外统一暴露接口: resolve, then
                    - 每个接口内部封装了包括: 并行语义、执行结构等全部逻辑

[top](#catalog)