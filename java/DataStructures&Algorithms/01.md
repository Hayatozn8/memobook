<span id="catalog"></span>
- [稀疏数组和队列](#稀疏数组和队列)

* 线性结构
	* 数据元素之间存在一对一的线性关系
	* 两种存储结构
		* 顺序存储结构--数组(数据的存储地址是连续的)
		* 链式存储结构--链表
	* 常见线性结构
		* 数组
		* 队列
		* 链表
		* 栈
* 非线性结构
	* 常见非线性结构
		* 二维数组
		* 多维数组
		* 广义表
		* 树
		* 图

# 稀疏数组和队列
## 稀疏数组sparsearray
* 当一个数组中大部分元素为0或同一个值时，可以使用稀疏数组来保存该数组
* 稀疏数组的处理方法：
	1. 记录数组共有几行几列，有多少不同的值
	2. 把具有不同值的元素的行、列、值记录在一个小规模的数组中，以此来减少数组的容量
* 稀疏数组与二维数组的互转实例
	```java
	int[][] chessArr1 = new int[11][11];
	chessArr1[1][2] = 1;
	chessArr1[2][3] = 2;
	chessArr1[4][7] = 1;
	
	for(int[] row : chessArr1){
		for(int item : row){
			System.out.print(item);
		}
		System.out.println();
	}
	
	// 1. 二维数组 ---> 稀疏数组
	// 统计数组中有效元素的数量(！=0)
	int sum = 0;
	for(int i=0; i<chessArr1.length; i++){
		for(int j=0; j<chessArr1[i].length; j++){
			if (chessArr1[i][j] !=0 ){
				sum++;
			}
		}
	}
	
	System.out.println(sum);
	
	// 根据有效元素的数量创建稀疏数组(三列:行、列、元素值；第一行记录：原数组的行数，原数组的列数，共有多少有效数据)
	int sparseArr[][] = new int[sum+1][3];
	sparseArr[0][0] = 11;
	sparseArr[0][1] = 11;
	sparseArr[0][2] = sum;
	
	// 遍历原数组，将有效值及其行、列保存到稀疏数组中
	int count=0;
	for(int i=0; i<chessArr1.length; i++){
		for(int j=0; j<chessArr1[i].length; j++){
			if (chessArr1[i][j] !=0 ){
				count++;
				sparseArr[count][0] = i;
				sparseArr[count][1] = j;
				sparseArr[count][2] = chessArr1[i][j];
			}
		}
	}
	
	// 打印稀疏数组
	for(int i=0; i<sparseArr.length; i++){
		System.out.printf("%d\t%d\t%d\n", sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
	}
	
	// 2. 稀疏数组 ---> 二维数组
	int[][] cherrArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
	for(int i=1; i<sparseArr.length; i++){
		cherrArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
	}
	
	for(int[] row : cherrArr2){
		for(int item : row){
			System.out.print(item);
		}
		System.out.println();
	}
	```
* 需求:五子棋程序，能够存盘退出和续上盘
	* 最直接的方法：使用二维数组保存数据
******************************************************************
