<span id="catalog"></span>
- [稀疏数组和队列](#稀疏数组和队列)

* 线性结构
	* 数据元素之间存在一对一的线性关系
	* 两种存储结构
		* 顺序存储结构--数组(数据的存储地址是连续的)
		* 链式存储结构--链表
	* 常见线性结构
		* 数组
		* 队列
		* 链表
		* 栈
* 非线性结构
	* 常见非线性结构
		* 二维数组
		* 多维数组
		* 广义表
		* 树
		* 图

# 稀疏数组和队列
## 稀疏数组sparsearray
* 当一个数组中大部分元素为0或同一个值时，可以使用稀疏数组来保存该数组
* 稀疏数组的处理方法：
	1. 记录数组共有几行几列，有多少不同的值
	2. 把具有不同值的元素的行、列、值记录在一个小规模的数组中，以此来减少数组的容量

* 稀疏数组与二维数组的互转实例
	```java
	int[][] chessArr1 = new int[11][11];
	chessArr1[1][2] = 1;
	chessArr1[2][3] = 2;
	chessArr1[4][7] = 1;
	
	for(int[] row : chessArr1){
		for(int item : row){
			System.out.print(item);
		}
		System.out.println();
	}
	
	// 1. 二维数组 ---> 稀疏数组
	// 统计数组中有效元素的数量(！=0)
	int sum = 0;
	for(int i=0; i<chessArr1.length; i++){
		for(int j=0; j<chessArr1[i].length; j++){
			if (chessArr1[i][j] !=0 ){
				sum++;
			}
		}
	}
	
	System.out.println(sum);
	
	// 根据有效元素的数量创建稀疏数组(三列:行、列、元素值；第一行记录：原数组的行数，原数组的列数，共有多少有效数据)
	int sparseArr[][] = new int[sum+1][3];
	sparseArr[0][0] = 11;
	sparseArr[0][1] = 11;
	sparseArr[0][2] = sum;
	
	// 遍历原数组，将有效值及其行、列保存到稀疏数组中
	int count=0;
	for(int i=0; i<chessArr1.length; i++){
		for(int j=0; j<chessArr1[i].length; j++){
			if (chessArr1[i][j] !=0 ){
				count++;
				sparseArr[count][0] = i;
				sparseArr[count][1] = j;
				sparseArr[count][2] = chessArr1[i][j];
			}
		}
	}
	
	// 打印稀疏数组
	for(int i=0; i<sparseArr.length; i++){
		System.out.printf("%d\t%d\t%d\n", sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
	}
	
	// 2. 稀疏数组 ---> 二维数组
	int[][] cherrArr2 = new int[sparseArr[0][0]][sparseArr[0][1]];
	for(int i=1; i<sparseArr.length; i++){
		cherrArr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
	}
	
	for(int[] row : cherrArr2){
		for(int item : row){
			System.out.print(item);
		}
		System.out.println();
	}
	```
* 二维数组&稀疏数组转换
	* 二维数组-->稀疏数组
		1. 遍历二维数组，获得有效数据的个数：sum
		2. 创建稀疏数组：int[sum+1][3] (第一行记录数组是几行、几列、有几个有效数据)
		3. 将二维数组的有效数据保存到稀疏数组
	* 稀疏数组-->二维数组
		1. 读取稀疏数组的第一行，根据第一行保存的行数与列数创建原始的二维数组
		2. 读取后面的行，分别给对应位置的元素赋值

## 队列
* 队列是一个有序列表，可以用数组或链表来实现
	* 用数组存储称为顺序存储
	* 用链表存储称为链式存储
* 遵循先入先出原则
* 数组模拟队列(需要将数组模拟成环形队列)
	*　未使用环形队列，只能使用一次，无法复用
		* front 指向队列头部 --- 指向队列头的前一个位置
		* rear 指向队列尾部，就是直接指向尾部的数据
		｀｀｀java
		class ArrayQueue {
			private int maxSize;
			private int front;
			private int rear;
			private int[] arr;
			
			public ArrayQueue(int maxSize){
				this.maxSize = maxSize;
				arr = new int[maxSize];
				front = -1;
				rear = -1;
			}
			
			public boolean isFull(){
				return rear == maxSize - 1;
			}
			
			public boolean isEmpty(){
				return front == rear;
			}
			
			public void addQueue(int n){
				if (isFull()){
					System.out.println("the queue has been fulled");
					return;
				}
				rear++;
				arr[rear] = n; // arr[rear++] = n;
			}
			
			public int popQueue(){
				if (isEmpty()){
					throw new RuntimeException("the queue is null,can not pop");
				}
				
				front++;
				return arr[front];
			}
			
			public void showQueue(){
				if (isEmpty()){
					System.out.println("the queue is null");
				}
				
				for(int i=front+1; i<=rear; i++){
					System.out.printf("arr[%d] = %d\t", i, arr[i]);
				}
			}
			
			public int headQueue(){
				if (isEmpty()){
					throw new RuntimeException("the queue is null");
				}
				return arr[front + 1];
			}
		}
		```

	* 使用数组模拟环形队列
		* front 指向队列的第一个元素 初始值=0
		* rear 指向最后一个元素+1，**空出一个空间做约定** 初始值=0
			* 在这种约束下，rear会默认占用一个元素空间，整体的可以空间为maxsize-1
		* 当队列满时，[rear + 1] %maxSize = front
		* 队列为空，rear = front
		*　有效的数据个数　（ｒｅａｒ＋ｍａｘｓｉｚｅ－ｆｒｏｎｔ）％ｍａｘｓｉｚｅ
		```java
		@Test
		public void test(){
			ArrayQueue q = new ArrayQueue(4);
			q.show();
			q.add(2);
			q.add(3);
			q.add(4);
			q.add(5);
			q.add(6);
			q.show();
			System.out.println();
			System.out.println(q.head());
			
			System.out.println(q.pop());
			System.out.println(q.pop());
			q.add(6);
			q.add(7);
			q.add(8);
			System.out.println();
			q.show();
		}
		
		class ArrayQueue{
			int maxsize;
			int front;
			int rear;
			int[] queue;
			
			public ArrayQueue(int maxsize){
				this.maxsize = maxsize;
				this.queue = new int[maxsize];
				front = 0; //默认使用0
				rear = 0; //默认使用0
			}
			
			public boolean isEmpty(){
				return rear == front;
			}
			
			public boolean isFull(){
				return (rear + 1) % maxsize == front;
			}

			public int size(){
				return (rear + maxsize - front) % maxsize;
			}
			
			public void show(){
				if (isEmpty()){
					System.out.println("is empty");
				}
				for (int i=front; i<front+size(); i++){
					System.out.println(queue[i%maxsize]);
				}
			}
			
			public void add(int v){
				if (isFull()){
					System.out.println("is full");
					return;
				}
				
				queue[rear] = v;
				rear = (rear + 1) % maxsize;
			}
			
			public int pop(){
				if (isEmpty()){
					throw new RuntimeException("is empty");
				}
				
				int v = queue[front];
				front = (front + 1) % maxsize;
				return v;
			}
			
			public int head(){
				if (isEmpty()){
					throw new RuntimeException("is empty");
				}
				
				return queue[front];
			}
		}
		```

* 链表linked list
	* 有序列表，以节点的方式来存储，各节点间不一定连续
	* 节点的组成： `|数据域|next域（指针域，指向下一个节点）|`
	* 链表可以分为带头节点和不带头节点的链表
		* 头节点一般只记录next域(第一个节点的位置)
	* 带头节点的单链表
		* 先创建一个头节点，用来表示单链表的头
		* 每添加一个节点，直接添加到链表的最后
		* 基本功能
			* 遍历
				* 通过一个临时变量，来辅助遍历链表
			* 按照插入顺序添加
				* 找到最后一个节点，将新节点与最后一个节点连接
			* 按照某个key的顺序添加，且key不能重复
				* 需要先找到添加元素的位置
				* 重新建立元素间的next连接
			* 删除节点
				* 需要先找到**目标节点的前一个节点**
					* 如果只是查找目标节点，则删除时，还需要查找当前节点的前一个节点
				* 被删除的节点没有指向，将会被GC
			```java
			class Node {
				int no;
				String name;
				Node next;
				
				public Node(int no, String name){
					this.no = no;
					this.name = name;
				}
				
				public String toString(){
					return "Node [ no = " + no + ", name = "+ name + " ]";
				}
			}

			class LinkedList {
				private Node head = new Node(-1, "");
				
				//按照插入顺序添加
				public void add(Node n){
					Node cur = head;
					while(cur.next != null){
						cur = cur.next;
					}
					
					cur.next = n;
				}
				
				//遍历
				public void show(){
					if (head.next == null){
						System.out.println("is empty");
						return;
					}
					
					Node cur = head.next;
					while(cur != null){
						System.out.println(cur);
						cur = cur.next;
					}
				}
				
				//按照某个key的顺序添加，且key不能重复
				public void addOredrby(Node n){
					Node cur = head;
					while(cur.next != null){
						if (cur.next.no > n.no){
							n.next = cur.next;
							cur.next = n;
							return;
						} else if (cur.next.no == n.no){
							System.out.println("node is exists");
							return;
						}
						cur = cur.next;
					}
					
					n.next = cur.next;
					cur.next = n;
				}
				
				//删除节点
				public void del(int no){
					if (head.next == null){
						System.out.println("is empty");
					}
				
					Node cur = head;
					while(cur.next != null){
						if (cur.next.no == no){
							cur.next = cur.next.next;
							return;
						}
						cur = cur.next;
					}
					
					System.out.println("not find node");
				}
			}
			```
	* 单链表面试题
		* 求单链表中的有效节点个数
			```java
			public int count(){
				int count = 0;
				Node temp = head.next;
				while(temp != null){
					count++;
					temp = temp.next;
				}
				return count;
			}
			```
		* 查找单链表中的倒数第k个节点
			```go
			public Node revertFind(int index){
				int len = this.count();
				
				if (len == 0){
					//throw new RuntimeException("list is null");
					return null;
				}
				
				if (len < index){
					throw new RuntimeException("illegal index");
					return null;
				}
				
				Node temp = head.next;
				for (int i=0; i<len - index; i++){
					temp = temp.next;
				}
				
				return temp;
			}
			```
		* 单链表的反转
			```java
			public void reverse(){
				// 如果链表无节点，或只有一个结点，则无需反转
				if (head.next == null || head.next.next == null){
					return;
				}
				
				Node temp = head.next; //从旧节点的有效节点开始转换
				Node tempNext = null; 
				Node reverseHead = new Node(0, "");
				// 保持反转链表的头节点不变
				// 每次从就链表中抽取新节点，并保存该节点指向的下一个节点
				// 然后将该节点与反转链表的头节点连接
				while(temp != null){
					tempNext = temp.next; //保存当前节点指向的下一个节点
					// 将当前节点与反转链表的头节点连接
					temp.next = reverseHead.next; 
					reverseHead.next = temp;
					// 跳转到旧链表的下一个节点
					temp = tempNext;
				}
				
				head = reverseHead;// 重新设定头节点
				//head.next = reverseHead.next //重新设定头节点的指向也可以
			}
			```
		* 逆序输出单链表
			* 可以先反转在输出，但是会影响原始的链表结构
			* 利用栈stack，将节点压入栈中，再输出(java.util.Stack)
			```java
			public void reverseShow(){
				if (head.next == null){
					System.out.println("the linkedList is null");
				} else if (head.next.next == null){
					System.out.println(head.next);
				} else {
					Stack<Node> s = new Stack();
					Node temp = head.next;
					while(temp != null){
						s.add(temp);
						temp = temp.next;
					}
					
					while(s.size() > 0 ){
						System.out.println(s.pop());
					}
				}
			}
			```
		* 合并两个有序链表
			```java
			public static SingleLinkedList mergeList(SingleLinkedList sl1, SingleLinkedList sl2){
				Node cur1 = sl1.head.next;
				Node cur2 = sl2.head.next;
				SingleLinkedList newSl = new SingleLinkedList();
				Node temp =  newSl.head;
				while (cur1 != null && cur2 != null){
					if (cur1.no < cur2.no){
						temp.next = cur1;
						cur1 = cur1.next;
					} else {
						temp.next = cur2;
						cur2 = cur2.next;
					}
					
					temp = temp.next;
				}
				
				while(cur1 != null){
					temp.next = cur1;
					cur1 = cur1.next;
					temp = temp.next;
				}
				
				while(cur2 != null){
					temp.next = cur2;
					cur2 = cur2.next;
					temp = temp.next;
				}
				
				return newSl;
			}
			```
	* 双向链表
		```java
		class DoubleLinkedList{
			private Node head = new Node(0, "");
			
			public void add(Node node){
				Node temp = head;
				
				while (temp.next != null){
					temp = temp.next;
				}
				temp.next = node;
				node.pre = temp;
			}
			
			public void addByOrder(Node node){
				Node temp = head;
				boolean flag = false;
				
				while (temp.next != null){
					if (temp.next.no > node.no){
						break;
					} else if (temp.next.no == node.no){
						flag = true;
						break;
					}
					temp = temp.next;
				}
				
				if (flag){
					throw new RuntimeException("is exists");
				} else {
					node.pre = temp;
					node.next = temp.next;
					// 如果是最后一个节点的next为null，跳过该操作
					if (temp.next != null){
						temp.next.pre = node;
					}
					
					temp.next = node;
				}
			}
			
			public void del(int no){
				if (head.next == null){
					System.out.println("empty list");
					return;
				}
				
				Node temp = head.next;
				boolean match = false;
				while(temp != null){
					if (temp.no == no){
						match = true;
						break;
					}
					temp = temp.next;
				}
				
				if (match){
					temp.pre.next = temp.next;
					// 如果是最后一个节点的next为null，跳过该操作
					if (temp.next != null) {
						temp.next.pre = temp.pre;    
					}
				} else {
					System.out.println("can not match node");
				}
			}
						
			public void show(){
				if (head.next == null){
					System.out.println("the linkedList is null");
					return;
				}
				
				Node temp = head.next;
				while (true){
					if (temp == null){
						break;
					}
					
					System.out.println(temp);
					temp = temp.next;
				}
			}
		}

		class Node {
			public int no;
			public String name;
			public Node next;
			public Node pre;
			
			public Node(int no, String name){
				this.no = no;
				this.name = name;
			}
			
			public String toString(){
				return "Node [no" + no + ", name=" + name + "]";
			}
		}
		```
	* 单向环形链表的应用--约瑟夫问题
		```java
		class test  
		{
			public static void main (String[] args) throws java.lang.Exception
			{
				CircleSingleLinkedList llist = new CircleSingleLinkedList();
				llist.add(5);
				llist.show();
				System.out.println();
				
				System.out.println(llist.count());
				llist.outLine(1,2);
			}
		}

		class CircleSingleLinkedList {
			private Node first = null;//new Node(-1, "");
			
			public void add(int nums){
				if (nums < 1){
					System.out.println("nums < 1");
					return;
				}
				
				// 构造第一个元素
				Node cur = new Node(1, "1");
				first = cur;
				first.next = first;
				
				// 构造剩余元素
				for(int i=2; i<=nums; i++){
					Node node = new Node(i, String.valueOf(i));
					cur.next = node;
					node.next = first;
					cur = node;
				}
			}
			
			public void show(){
				if (first == null){
					System.out.println("list is null");
					return;
				}
				
				Node cur = first;
				while(true){
					System.out.println(cur);
					if (cur.next == first){
						break;
					}
					cur = cur.next;
				}
			}
			
			public int count(){
				if (first == null){
					return 0;
				}
				
				int count=0;
				Node cur = first;
				while(true){
					count++;
					if (cur.next == first){
						return count;
					}
					cur = cur.next;
				}
			}
			
			public void outLine(int start, int countNum){
				if (first == null){
					System.out.println("null list");
					return;
				}
				
				if (start < 1 || start > count()){
					System.out.println("illegal start");
					return;
				}
				
				//定位helper到first的前一个node
				Node cur = first;
				while(cur.next != first){
					cur = cur.next;
				}
				Node helper = cur;
				
				//移动到指定开始位置，移动k-1次
				for (int i=0; i < start-1; i++){
					first = first.next;
					helper = helper.next;
				}
				
				while(first != helper){
					// 移动到相对位置的第countNum个元素，移动countNum-1次
					for (int i=0; i<countNum-1; i++){
						first = first.next;
						helper = helper.next;
					}
					
					System.out.println(first);
					first = first.next;
					helper.next = first;
				}
				
				System.out.println(first);
			}
		}

		class Node {
			public int no;
			public String name;
			public Node next;
			
			public Node(int no, String name){
				this.no = no;
				this.name = name;
			}
			
			public String toString(){
				return "Node [no" + no + ", name=" + name + "]";
			}
		}
		```
* 栈
	* 使用数组模拟栈
		* index=0 为栈底
		* top表示栈顶，初始化为-1
		* 入栈push，top++，添加数据
		* 出栈pop，top--，返回数据
		```java
		class test  
		{
			public static void main (String[] args) throws java.lang.Exception
			{
				ArrayStack s = new ArrayStack(5);
				s.push(2);
				s.push(1);
				s.push(5);
				s.push(6);
				s.push(3);
				s.push(0);
				s.show();
				System.out.println();
				System.out.println(s.pop());
				System.out.println(s.pop());
				System.out.println();
				s.show();
			}
		}

		class ArrayStack{
			private int maxSize;
			private int top = -1;
			private int[] stack;
			
			public ArrayStack(int maxSize){
				this.maxSize = maxSize;
				stack = new int[maxSize];
			}
			
			public boolean isFull(){
				return top + 1 == maxSize;
			}
			
			public boolean isEmpty(){
				return top == -1;
			}
			
			public void push(int v) {
				if (isFull()){
					System.out.println("is full");
					return;
				}
				top++;
				stack[top] = v;
			}
			
			public int pop(){
				if (isEmpty()){
					throw new RuntimeException("is empty");
				}
				
				int v = stack[top];
				top--;
				return v;
			}
			
			// 从栈顶到栈底显示数据
			public void show(){
				if (isEmpty()){
					System.out.println("is empty");
					return;
				}
				for(int i=top; i>=0; i--){
					System.out.println(stack[i]);
				}
			}
		}
		```
	* 使用栈实现一个计算器(中缀表达式)
		* 一个数栈保存参数，一个符号栈保存运算符
		* 通过一个index，来遍历输入的表达式
			* 如果是一个数，则放入数栈
			* 如果是一个符号，则：
				* 如果符号栈为空，则直接入栈
				* 如果符号栈有操作符，则进行比较
					* 如果当前操作符的优先级 <= 栈顶的操作符
						* 需要从数栈中pop出两个数
						* 再从符号栈中pop出一个运算符
						* 进行计算
						* 将计算结果放入数栈
						* 将当前的操作符放入符号栈
					* 如果当前操作符的优先级 > 栈顶的操作符
						* 将操作符放入符号栈
			* 表达式扫描完后，顺序的从数栈和符号栈pop出数和符号进行运算
			* 最终数栈只有一个最终结果，即表达式的最终结果
		* 多位数的处理
			* 不能发现一个数后立即入栈
			* 发现一个数后需要向后再看一位，如果是数则继续扫描，如果是运算符则入栈
		```java
		class Calculator{
			public static void main(String[] args){
				String exp = "3+2*6-2";
				//创建数栈和符号栈
				ArrayStack2 numStack = new ArrayStack2(10);
				ArrayStack2 operStack = new ArrayStack2(10);
				
				
				int num1 = 0;
				int num2 = 0;
				int oper = 0;
				char ch = ' '; //保存每次扫描得到的字符
				
				String tempNum = ""; //用于拼接多位数
				// 入栈
				for (int i=0; i<exp.length(); i++){
					ch = exp.charAt(i);
					//判断ch是数字还是操作符
					if (operStack.isOper(ch)){
						if (!"".equals(tempNum)){
							numStack.push(Integer.parseInt(tempNum));
							tempNum = "";
						}
						if (operStack.isEmpty()){
							operStack.push(ch);
						} else {
							if (operStack.priority(ch) <= operStack.priority(operStack.peek())){
								num1 = numStack.pop();
								num2 = numStack.pop();
								oper = operStack.pop();
								numStack.push(numStack.cal(num1, num2, oper));
								operStack.push(ch); //使用[<=]不会产生需要循环弹出操作符进行运算的情况
							} else {
								operStack.push(ch);
							}
						}
					} else {
						//numStack.push(ch - 48)； // '1' = 49
						tempNum += ch;
					}
				}
				
				//输出最后的数值
				if (!"".equals(tempNum)){
					numStack.push(Integer.parseInt(tempNum));
				}
				
				//全部出栈并计算
				while (!operStack.isEmpty()){
					//如果符号栈为空则计算结束
					num1 = numStack.pop();
					num2 = numStack.pop();
					oper = operStack.pop();
					numStack.push(numStack.cal(num1, num2, oper));
				}
				
				System.out.println(numStack.pop());
			}
		}

		//
		class ArrayStack2{
			private int maxSize;
			private int top = -1;
			private int[] stack;
			
			public ArrayStack2(int maxSize){
				this.maxSize = maxSize;
				stack = new int[maxSize];
			}
			
			public boolean isFull(){
				return top + 1 == maxSize;
			}
			
			public boolean isEmpty(){
				return top == -1;
			}
			
			public void push(int v) {
				if (isFull()){
					System.out.println("is full");
					return;
				}
				top++;
				stack[top] = v;
			}
			
			public int pop(){
				if (isEmpty()){
					throw new RuntimeException("is empty");
				}
				
				int v = stack[top];
				top--;
				return v;
			}
			
			//查看栈顶元素
			public int peek(){
				return stack[top];
			}
			
			// 从栈顶到栈底显示数据
			public void show(){
				if (isEmpty()){
					System.out.println("is empty");
					return;
				}
				for(int i=top; i>=0; i--){
					System.out.println(stack[i]);
				}
			}
			
			// 返回运算符的优先级
			public int priority(int oper){
				if (oper == '*' || oper == '/'){
					return 1;
				} else if (oper == '+' || oper == '-'){
					return 0;
				} else {
					return -1;
				}
			}
			
			//判断字符是不是一个运算符
			public boolean isOper(char val){
				return val == '+' || val == '-' || val == '*' || val == '/';
			}
			
			//计算方法
			// num1是先弹出的数字，num2是后弹出的数字
			public int cal(int num1, int num2, int oper){
				int result = 0;
				
				switch (oper){
					case '+':
						result = num2 + num1;
						break;
					case '-':
						result = num2 - num1;
						break;
					case '*':
						result = num2 * num1;
						break;
					case '/':
						result = num2 / num1;
						break;
					default:
						break;
				}
				
				return result;
			}
		}
		```
* 前缀、中缀、后缀表达式
	* 前缀表达式/波兰表达式
		* 运算符位于操作数之前
		* 如：`(3+4)*5-6  --> - * + 3 4 5 6` 
		* 前缀表达式的计算机求值
			* 从右向左扫描表达式
			* 遇到数字压入堆栈
			* 遇到运算符，弹出栈顶的两个数，做运算，再将计算结构入栈
	* 中缀表达式
		* 常见的运算表达式
		* 中缀表达式不适合计算机处理，一般会被转换为后缀表达式
	* 后缀表达式/逆波兰表达式
		* 如：`(3+4)*5-6  --> 3 4 + 5 × 6 -`
		* 表达式的基本转换
			
			|基本表达式|后缀表达式|
			|-|-|
			|a+b|a b +|
			|a+(b-c)|a b c - +|
			|a+(b-c)*d|a b c - d * +|
			|||
			|||
******************************************************************
