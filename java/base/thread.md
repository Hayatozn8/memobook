<span id="catalog"></span>
- [并发编程的问题](#并发编程的问题)
- [Java并发机制的底层实现原理](#Java并发机制的底层实现原理)
    - [volatile的原理与应用](#volatile的原理与应用)
    - [synchronized的原理与应用](#synchronized的原理与应用)
- [](#)
- [](#)
- [](#)
- [](#)
- [](#)

# 并发编程的问题
[top](#catalog)
- 上下文切换
    - 如何减少上下文切换
        - 无锁并发编程
            - 多线程竞争锁时，会引起上下文切换
            - 避免方法，如：将数据的ID按照Hash算法取模分段，不同的哦线程处理不同段的数据
        - CAS算法
            - Java的Atomic包使用CAS算法来更新数据，不需要加锁
        - 使用最少线程
        - 使用协程
            - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的任务切换
- 死锁
    - 避免死锁的几种方法
        - 避免在一个线程同时获取多个锁
        - 避免在一个线程在锁内占用多个资源，尽量保证每个锁只占用一个资源
        - 尝试使用定时锁，使用`lock.tryLock(timeout)`来替代使用内部锁机制
        - 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况
- 资源限制
    - 资源限制是指：在并发编程时，程序的执行速度受限于计算机硬件资源或软件资源
    - 硬件资源
        - 宽带的上传/下载速度
        - 硬盘读写速度
        - CPU的处理速度
    - 软件资源，如：
        - 数据库的连接数
        - socket连接数
    - 资源限制导致的问题
        - 多线程受限于资源，仍然在串行执行
        - 由于增加了上下文切换和资源调度，导致执行变慢
    - 如何解决资源受限
        - 对于硬件资源限制
            - 使用集群并行执行程序
                - 如通过`数据ID % 机器数`来得到一个机器编号，然后有对应的机器来执行
        - 对于软件资源限制
            - 可以使用资源池来**复用资源**，如：
                - 使用连接池来复用数据库和socket连接
                - 在调用对方webservice接口获取数据时，只建立一个连接
    - 如何在资源限制情况下进行并发编程
        - 根据不同的资源限制调整程序的并发度

# Java并发机制的底层实现原理
[top](#catalog)
- java代码的运行
    1. java代码-->编译-->java字节码
    2. java字节码-->类加载器-->加载到JVM
    3. JVM执行字节码-->汇编指令-->在CPU上执行
- java中使用的并发机制依赖于jvm的实现和cpu指令

## volatile的原理与应用
[top](#catalog)
- `volatile`的基本概念
    - 是轻量级的`synchronized`
    - 在多处理器开发中保证了共享变量的可见性
    - 可见性：当一个线程修改一个共享变量时，另一个线程能读到这个修改后的值
    - **不会引起线程上下文的切换和调度**
        - 如果使用得当，它比`synchronized`的使用和执行成本更低

- 一些CPU术语

|术语|英文|描述|
|-|-|-|
|内存屏障|memory barriers|是一组处理器指令，用于实现对内存操作的顺序限制|
|缓存行|cache line|缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期|
|原子操作|atomic operations|不可中断的一个或一系列操作|
|缓存行填充|cache line fill|当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存（L1，L2，L3 或所有）|
|缓存命中|cache hit|如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取|
|写命中|write hit|当处理器将操作数写回到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写回到缓存，而不是写回到内存，这个操作被称为写命中|
|写缺失|write misses the cache|一个有效的缓存行被写入到不存在的内存区域|

- `volatile`的定义与实现原理
    - 如果一个字段被声明成`volatile`，Java线程内存模型确保**所有线程看到这个变量的值是一致的**
    - 对`volatile`修饰的共享变量进行写操作时，在汇编代码中会多出一行`lock`代码
        - Lock的操作
            - 将当前处理器缓存行的数据写回到系统内存
            - 写回操作会使其他CPU核心中缓存了该内存地址的数据无效化
    - `volatile`的两条原则
        - Lock前缀指令会引起处理器缓存回写到内存
        - 一个处理器的缓存回写到内存会导致其他处理器的缓存无效
- `volatile`的使用优化
    - `LinkedTransferQueue`，通过追加字节的方式来优化性能
        - 追加字节到64个字节，15个填充对象+当前对象自身，共64字节，一次读取填满一个缓存行
        - 填满后，即头节点占满了一个缓存行，进行入队和出队操作时，就可以避免在一个缓存行中不停的修改数据，而其他处理器不能访问的问题，提高了多处理器下的性能

    - 不是所有的`volatile`变量都应该追加到64字节
        - 缓存行不是64字节的处理器
        - 共享变量不会被频繁地写
            - 追加字节的方式需要处理器读取更多的字节到高速缓存区，这本身就会带来一定的性能消耗
            - 如果共享变量不会被频繁地写，锁的几率也非常小，就没有必要通过追加字节来避免相互锁定

    - 追加字节的方式在Java7中下可能不生效
        - Java7会淘汰或重新排列无用字段，需要使用其他追加字节的方式


## synchronized的原理与应用
[top](#catalog)
- `JavaSE 1.6`对`synchronized`进行了优化，有些情况下不再是`重量级锁`
    - 减少`获取锁/释放锁`带来的性能消耗的优化
        - 引入`偏向锁`和`轻量级锁`
        - 锁的存储结构和升级过程 ???????????????/
- `synchronized`实现同步的基础:Java中的每一个对象都可以作为锁，表现为3点
    1. `synchronized`方法，锁是当前实例对象
    2. `synchronized`类，锁是当前类的Class对象?????????
    3. `synchronized`代码块，锁是`()`中配置的对象
- 访问同步代码时，必须先得到锁，**退出或抛出异常时必须释放锁**

- `synchronized`**在JVM中的实现原理**
    - JVM基于进入和退出`Monitor`对象来实现方法同步和代码块同步  ????????????????Monitor对象
        - 但方法和代码块的实现细节不一样

    - JVM的实现
        - 代码块同步使用： `monitorenter`, `monitorexit`指令实现
        - 方法同步的实现细节在JVM规范中没有详细说明
            - 方法同步也可以使用`monitorenter`和`monitorexit`指令实现
        - `monitorenter`指令是在**编译后**插入到同步代码块的开始位置
        - `monitorexit`指令是在**编译后**插入到同步代码块的结束位置和异常位置

    - 加锁的过程
        - 前提：
            - JVM会保证**每个monitorenter必须有对应的monitorexit**
            - 任何对象都有一个`monitor`与之关联

        - 当一个`monitor`被持有后，它将处于锁定状态
        - 线程执行到`monitorenter`指令时，会尝试获取对象所对应的`monitor`的所有权，即**尝试获得对象的锁**

[top](#catalog)
