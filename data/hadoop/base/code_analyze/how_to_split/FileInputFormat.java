@InterfaceAudience.Public
@InterfaceStability.Stable
public abstract class FileInputFormat<K, V> extends InputFormat<K, V> {

  public List<InputSplit> getSplits(JobContext job) throws IOException {
    StopWatch sw = new StopWatch().start();

    // 4. 获取切片数
    // 4.1 最小切片数: 1
    long minSize = Math.max(getFormatMinSplitSize(), getMinSplitSize(job));
    // 4.2 最大切片数
    long maxSize = getMaxSplitSize(job);

    // generate splits
    List<InputSplit> splits = new ArrayList<InputSplit>();
    List<FileStatus> files = listStatus(job);

    // 4.3 遍历提交的所有文件，对每一个文件尝试切片
    for (FileStatus file: files) {
      Path path = file.getPath();

      // 5. 获取文件大小
      long length = file.getLen();
      if (length != 0) {
        BlockLocation[] blkLocations;
        if (file instanceof LocatedFileStatus) {
          blkLocations = ((LocatedFileStatus) file).getBlockLocations();
        } else {
          FileSystem fs = path.getFileSystem(job.getConfiguration());
          blkLocations = fs.getFileBlockLocations(file, 0, length);
        }
        // 6. 判断文件是否可分割
        if (isSplitable(job, path)) {
          // 7. 获取块的大小: 本地运行为 32M， yarn 运行为 128M
          long blockSize = file.getBlockSize();
          // 8. 根据块大小，计算文件每个切片的大小
          long splitSize = computeSplitSize(blockSize, minSize, maxSize);

          long bytesRemaining = length;

          // SPLIT_SLOP = 1.1
          // 如果: `文件的剩余容量 / 数据块大小 > 1.1` 时， 添加新的切片
          // bytesRemaining 初始为文件的大小
          while (((double) bytesRemaining)/splitSize > SPLIT_SLOP) {
            int blkIndex = getBlockIndex(blkLocations, length-bytesRemaining);
            splits.add(makeSplit(path, length-bytesRemaining, splitSize,
                        blkLocations[blkIndex].getHosts(),
                        blkLocations[blkIndex].getCachedHosts()));
            bytesRemaining -= splitSize;
          }

          if (bytesRemaining != 0) {
            int blkIndex = getBlockIndex(blkLocations, length-bytesRemaining);
            splits.add(makeSplit(path, length-bytesRemaining, bytesRemaining,
                       blkLocations[blkIndex].getHosts(),
                       blkLocations[blkIndex].getCachedHosts()));
          }
        } else {
          // 不切片
          splits.add(makeSplit(path, 0, length, blkLocations[0].getHosts(),
                      blkLocations[0].getCachedHosts()));
        }
      } else { 
        //Create empty hosts array for zero length files
        splits.add(makeSplit(path, 0, length, new String[0]));
      }
    }
    // Save the number of input files for metrics/loadgen
    job.getConfiguration().setLong(NUM_INPUT_FILES, files.size());
    sw.stop();
    if (LOG.isDebugEnabled()) {
      LOG.debug("Total # of splits generated by getSplits: " + splits.size()
          + ", TimeTaken: " + sw.now(TimeUnit.MILLISECONDS));
    }
    return splits;
  }

  // 4.2 获取最大切片数
  public static long getMaxSplitSize(JobContext context) {
    // 如果设置了: mapreduce.input.fileinputformat.split.maxsize，则使用该属性作为最大切片数
    // 如果没有设置，则使用: Long.MAX_VALUE = 923372036854775807
    return context.getConfiguration().getLong(SPLIT_MAXSIZE,
                                              Long.MAX_VALUE);
  }


  // 8. 根据块大小，计算文件分片数量
  protected long computeSplitSize(long blockSize, long minSize,
                                  long maxSize) {
    // Math.max(1 , Math.min(923372036854775807, blockSize))，
    // 没有手动配置时，默认将会返回 blockSize
    // 增大需要设置: minSize
    // 减小需要设置: mapreduce.input.fileinputformat.split.maxsize
    return Math.max(minSize, Math.min(maxSize, blockSize));
  }
}